<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>设计模式：七大设计原则 | 杜圆圆的学习笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    
        <meta property="algolia:search" data-application-id="QVZKZA7CCN" data-api-key="3247c59b2591077db39388602665c9c2" data-index-name="my_blog">
    

    

    
    <link rel="icon" href="/images/icon-dyy.jpeg">
    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1637200696663.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1637200696663.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = false
        window.aomori_search_algolia = true

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <a class="header-type-title" href="/">杜圆圆的学习笔记</a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/dquaner">
        <box-icon type='logo' name='github'></box-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-claqvg83700127ja8hq1o1wlz" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      设计模式：七大设计原则
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2022-11-15T14:28:59.000Z" itemprop="datePublished">2022-11-15</time>
</div>

            
            <div class="article-category">
                <a class="article-category-link" href="/categories/Java/">Java</a>
            </div>
            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <p>软件工程中，设计模式（design pattern）是对软件设计中<strong>普遍存在</strong>的（<strong>反复出现</strong>）的各种问题，所提出的<strong>解决方案</strong>。</p>
<p>设计模式的目的：</p>
<ul>
<li>增强代码的重用性</li>
<li>可读性（编程规范性）</li>
<li>可扩展性（可维护性，易于添加新的功能）</li>
<li>可靠性（增加新的功能后，对原来的功能没有影响）</li>
<li>使程序呈现高内聚，低耦合的特性</li>
</ul>
<p>设计模式本身要遵守的七个原则：</p>
<ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒置原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ol>
<span id="more"></span>

<h1 id="1-单一职责原则（Single-Responsibility-Principle）"><a href="#1-单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="1.单一职责原则（Single Responsibility Principle）"></a>1.单一职责原则（Single Responsibility Principle）</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>对类来说，一个类应该只负责一项职责。</p>
<p>例如，class A 负责两个不同的两个职责：职责1，职责2。当因为 职责1 需求变更而改变 A 时，有可能造成 职责2 的执行错误，所以需要将 class A 分解为更细粒度的 A1，A2。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>以交通工具类为例：</p>
<p><i>Example 1.</i></p>
<pre><code class="java">public class SingleResponsibility &#123;
    public static void main(String[] args) &#123;
        Vehicle vehicle = new Vehicle();
        vehicle.run(&quot;motorbike&quot;);
        vehicle.run(&quot;car&quot;);
        vehicle.run(&quot;plane&quot;); // 逻辑错误
    &#125;
&#125;

/**
 * 1. 违反了单一职责原则
 * 2. 改进：为不同的交通工具创建不同的类 -&gt; Example 2
 */
class Vehicle &#123;
    public void run(String vehicle) &#123;
        System.out.println(vehicle + &quot; running on the road...&quot;);
    &#125;
&#125;
</code></pre>
<p><i>Example 2.</i></p>
<pre><code class="java">public class SingleResponsibility2 &#123;
    public static void main(String[] args) &#123;
        RoadVehicle roadvehicle = new RoadVehicle();
        roadvehicle.run(&quot;motorbike&quot;);
        roadvehicle.run(&quot;car&quot;);
        AirVehicle airVehicle = new AirVehicle();
        airVehicle.run(&quot;plane&quot;);
    &#125;
&#125;

/**
 * 1. 遵守单一职责原则
 * 2. 但是这样做改动很大，即将类分解，同时要修改客户端
 * 3. 改进：直接修改 Vehicle 类，改动的代码比较少 -&gt; Example 3
 */
class RoadVehicle &#123;
    public void run(String vehicle) &#123;
        System.out.println(vehicle + &quot; running on the road...&quot;);
    &#125;
&#125;

class AirVehicle &#123;
    public void run(String vehicle) &#123;
        System.out.println(vehicle + &quot; running in the air...&quot;);
    &#125;
&#125;

class WaterVehicle &#123;
    public void run(String vehicle) &#123;
        System.out.println(vehicle + &quot; running in the water...&quot;);
    &#125;
&#125;
</code></pre>
<p><i>Example 3.</i></p>
<pre><code class="java">public class SingleResponsibility3 &#123;
    public static void main(String[] args) &#123;
        Vehicle vehicle = new Vehicle();
        vehicle.runRoad(&quot;car&quot;);
        vehicle.runAir(&quot;plane&quot;);
        vehicle.runWater(&quot;boat&quot;);
    &#125;
&#125;

/**
 * 1. 这种修改方法没有对原来的类做大的修改，只是增加方法
 * 2. 虽然没有在类级别上遵守单一职责原则，但在方法级别上，仍然遵守了单一职责
 */
class Vehicle &#123;
    public void runRoad(String vehicle) &#123;
        System.out.println(vehicle + &quot; running on the road...&quot;);
    &#125;

    public void runAir(String vehicle) &#123;
        System.out.println(vehicle + &quot; running in the air...&quot;);
    &#125;

    public void runWater(String vehicle) &#123;
        System.out.println(vehicle + &quot; running in the water...&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h2><ol>
<li>降低类的复杂度，一个类只负责一项职责</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更一个职责带来的风险</li>
<li>通常情况下，我们应该遵守单一职责原则；只有逻辑足够简单时，才可以在类级别违反单一职责；只有类中的方法足够少时，可以在方法级别保持单一职责原则。</li>
</ol>
<h1 id="2-接口隔离原则（Interface-Segregation-Principle）"><a href="#2-接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="2.接口隔离原则（Interface Segregation Principle）"></a>2.接口隔离原则（Interface Segregation Principle）</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>先看一张图：<br><img src="interface_segregation_principle1.png" width="600"></p>
<p>class A 通过接口 Interface1 依赖 class B，class C 通过接口 Interface1 依赖 class D，如果 Interface1 对于 A 和 C 来说不是最小接口，那么 B 和 D 必须去实现它们不需要的方法。</p>
<p>按接口隔离原则应该这样处理：<br>将接口 Interface1 拆分为独立的几个接口，A 和 C 分别与它们需要的接口建立依赖关系。<br><img src="interface_segregation_principle2.png" width="500"></p>
<h2 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h2><p><i>Example 1.</i></p>
<pre><code class="java">interface Interface1 &#123;
    void operation1();
    void operation2();
    void operation3();
    void operation4();
    void operation5();
&#125;

class B implements Interface1 &#123;
    @Override
    public void operation1() &#123;
        System.out.println(&quot;B implements operation1&quot;);
    &#125;
    @Override
    public void operation2() &#123;
        System.out.println(&quot;B implements operation2&quot;);
    &#125;
    @Override
    public void operation3() &#123;
        System.out.println(&quot;B implements operation3&quot;);
    &#125;
    @Override
    public void operation4() &#123;
        System.out.println(&quot;B implements operation4&quot;);
    &#125;
    @Override
    public void operation5() &#123;
        System.out.println(&quot;B implements operation5&quot;);
    &#125;
&#125;

class D implements Interface1 &#123;
    @Override
    public void operation1() &#123;
        System.out.println(&quot;D implements operation1&quot;);
    &#125;
    @Override
    public void operation2() &#123;
        System.out.println(&quot;D implements operation2&quot;);
    &#125;
    @Override
    public void operation3() &#123;
        System.out.println(&quot;D implements operation3&quot;);
    &#125;
    @Override
    public void operation4() &#123;
        System.out.println(&quot;D implements operation4&quot;);
    &#125;
    @Override
    public void operation5() &#123;
        System.out.println(&quot;D implements operation5&quot;);
    &#125;
&#125;

/**
 * 1. A 通过 Interface1 依赖（使用）B
 * 2. 但是 A 中只会使用到 Interface1 的 1,2,3 三个方法，违反了接口隔离原则
 */
class A &#123;
    public void depend1(Interface1 i) &#123;
        i.operation1();
    &#125;
    public void depend2(Interface1 i) &#123;
        i.operation2();
    &#125;
    public void depend3(Interface1 i) &#123;
        i.operation3();
    &#125;
&#125;

/**
 * 1. C 通过 Interface1 依赖（使用）D
 * 2. 但是 C 中只会使用到 Interface1 的 1,4,5 三个方法，违反了接口隔离原则
 */
class C &#123;
    public void depend1(Interface1 i) &#123;
        i.operation1();
    &#125;
    public void depend4(Interface1 i) &#123;
        i.operation4();
    &#125;
    public void depend5(Interface1 i) &#123;
        i.operation5();
    &#125;
&#125;
</code></pre>
<p><i>Example 2.</i></p>
<pre><code class="java">public class Segregation &#123;
    public static void main(String[] args) &#123;
        A a = new A();
        B b = new B();
        a.depend1(b); // class A 通过接口去依赖 class B
        a.depend2(b);
        a.depend3(b);

        C c = new C();
        D d = new D();
        c.depend1(d); // class C 通过接口去依赖 class D
        c.depend4(d);
        c.depend5(d);
    &#125;
&#125;

interface Interface1 &#123;
    void operation1();
&#125;

interface Interface2 &#123;
    void operation2();
    void operation3();
&#125;

interface Interface3 &#123;
    void operation4();
    void operation5();
&#125;

class B implements Interface1, Interface2 &#123;
    @Override
    public void operation1() &#123;
        System.out.println(&quot;B implements operation1&quot;);
    &#125;
    @Override
    public void operation2() &#123;
        System.out.println(&quot;B implements operation2&quot;);
    &#125;
    @Override
    public void operation3() &#123;
        System.out.println(&quot;B implements operation3&quot;);
    &#125;
&#125;

class D implements Interface1, Interface3 &#123;
    @Override
    public void operation1() &#123;
        System.out.println(&quot;D implements operation1&quot;);
    &#125;
    @Override
    public void operation4() &#123;
        System.out.println(&quot;D implements operation4&quot;);
    &#125;
    @Override
    public void operation5() &#123;
        System.out.println(&quot;D implements operation5&quot;);
    &#125;
&#125;

/**
 * A 通过 Interface1, Interface2 依赖（使用）B
 */
class A &#123;
    public void depend1(Interface1 i) &#123;
        i.operation1();
    &#125;
    public void depend2(Interface2 i) &#123;
        i.operation2();
    &#125;
    public void depend3(Interface2 i) &#123;
        i.operation3();
    &#125;
&#125;

/**
 * C 通过 Interface1, Interface3 依赖（使用）D
 */
class C &#123;
    public void depend1(Interface1 i) &#123;
        i.operation1();
    &#125;
    public void depend4(Interface3 i) &#123;
        i.operation4();
    &#125;
    public void depend5(Interface3 i) &#123;
        i.operation5();
    &#125;
&#125;
</code></pre>
<h1 id="3-依赖倒置原则（Denpendency-Inversion-Principle）"><a href="#3-依赖倒置原则（Denpendency-Inversion-Principle）" class="headerlink" title="3.依赖倒置原则（Denpendency Inversion Principle）"></a>3.依赖倒置原则（Denpendency Inversion Principle）</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol>
<li>高层模块不应该依赖于低层模块，二者都应该依赖其抽象（接口或抽象类）。</li>
<li>抽象不应该依赖细节，细节应该依赖抽象。</li>
<li>中心思想：面向接口编程。</li>
<li>设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构稳定。在 Java 中，抽象指的是接口或抽象类，细节指的是具体的实现类。</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</li>
</ol>
<h2 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h2><p>编程完成 Person 类接收消息的功能。</p>
<p><i>Example 1.</i></p>
<pre><code class="java">public class DependencyInversion &#123;
    public static void main(String[] args) &#123;
        Person person = new Person();
        person.receive(new Email());
    &#125;
&#125;

class Email &#123;
    public String getInfo() &#123;
        return &quot;E-mail Info: Hello world!&quot;;
    &#125;
&#125;

/**
 * 方式1
 * 1. 简单，比较容易想到
 * 2. 如果我们获取的对象是微信，短信等，则要新增类，同时 Person 类要增加相应的接受方法
 * 3. 解决思路：引入一个抽象的接口 IReceiver，Person 类与接口 IReceiver 发生依赖，
 *    因为 Email，WeChat 等都属于接收的范围，他们各自实现 IReceiver 接口即可，这样做符合依赖倒置原则
 */
class Person &#123;
    public void receive(Email email) &#123;
        System.out.println(email.getInfo());
    &#125;
&#125;
</code></pre>
<p><i>Example 2.</i></p>
<pre><code class="java">public class DependencyInversion &#123;
    public static void main(String[] args) &#123;
        // 客户端无需改变
        Person person = new Person();
        person.receive(new Email());
        person.receive(new Wechat());
    &#125;
&#125;

interface IReceiver &#123;
    String getInfo();
&#125;

class Email implements IReceiver &#123;
    @Override
    public String getInfo() &#123;
        return &quot;E-mail Info: Hello world!&quot;;
    &#125;
&#125;

class Wechat implements IReceiver &#123;
    @Override
    public String getInfo() &#123;
        return &quot;Wechat Info: Hello ok!&quot;;
    &#125;
&#125;

/**
 * 方式2
 */
class Person &#123;
    public void receive(IReceiver receiver) &#123;
        System.out.println(receiver.getInfo());
    &#125;
&#125;
</code></pre>
<h2 id="依赖关系传递的三种方式和应用案例"><a href="#依赖关系传递的三种方式和应用案例" class="headerlink" title="依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h2><ol>
<li>接口传递</li>
</ol>
<pre><code class="java">/**
 * 方式1：通过接口传递实现依赖
 */
interface IOpenAndClose &#123;
    void open(ITV tv); //抽象方法，接收接口
&#125;

interface ITV &#123;
    void play();
&#125;

class OpenAndClose implements IOpenAndClose &#123;
    @Override
    public void open(ITV tv) &#123;
        tv.play();
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>构造方法传递</li>
</ol>
<pre><code class="java">/**
 * 方式2：通过构造方法传递依赖
 */
interface IOpenAndClose &#123;
    void open();
&#125;

interface ITV &#123;
    void play();
&#125;

class OpenAndClose implements IOpenAndClose &#123;
    private ITV tv;
    public OpenAndClose(ITV tv) &#123; //构造方法
        this.tv = tv;
    &#125;
    @Override
    public void open() &#123;
        this.tv.play();
    &#125;
&#125;
</code></pre>
<ol start="3">
<li>setter方法传递</li>
</ol>
<pre><code class="java">/**
 * 方式3：通过setter方法传递依赖
 */
interface IOpenAndClose &#123;
    void open();
    void setTv(ITV tv);
&#125;

interface ITV &#123;
    void play();
&#125;

class OpenAndClose implements IOpenAndClose &#123;
    private ITV tv;
    @Override
    public void setTv(ITV tv) &#123;
        this.tv = tv;
    &#125;
    @Override
    public void open() &#123;
        this.tv.play();
    &#125;
&#125;
</code></pre>
<h2 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h2><ol>
<li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。</li>
<li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间就存在一个缓冲层，利于程序扩展和优化。</li>
<li>继承时遵循里氏替换原则。</li>
</ol>
<h1 id="4-里氏替换原则（Liskov-Substitution-Principle）"><a href="#4-里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="4.里氏替换原则（Liskov Substitution Principle）"></a>4.里氏替换原则（Liskov Substitution Principle）</h1><h2 id="面向对象中的继承的思考和说明"><a href="#面向对象中的继承的思考和说明" class="headerlink" title="面向对象中的继承的思考和说明"></a>面向对象中的继承的思考和说明</h2><ol>
<li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li>
<li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他类所继承，则当这个类需要修改时，必须考虑到所有的子类；并且父类修改后，所有涉及到子类的功能都有可能产生故障。</li>
<li>在编程中，如何正确的使用继承？<strong>里氏替换原则</strong></li>
</ol>
<h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol>
<li>1988年，由麻省理工学院一位姓里的女士提出。</li>
<li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li>
<li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</li>
<li>里氏替换原则告诉我们，继承实际上让两个类的耦合性增强了，<strong>在适当的情况下，可以通过聚合，组合，依赖来解决问题</strong>。</li>
</ol>
<h2 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h2><p>一个程序引出的问题和思考：</p>
<pre><code class="java">class A &#123;
    public int func1(int num1, int num2) &#123;
        return num1-num2;
    &#125;
&#125;

class B extends A &#123;
    public int func1(int a, int b) &#123; // 不小心重写了父类的 func1 方法
        return a + b;
    &#125;
    public int func2(int a, int b) &#123; // 这里 B 想使用 A 的 func1 来新增一个功能
        return func1(a, b) + 9;
    &#125;
&#125;

A a = new A();
System.out.println(&quot;11-3=&quot; + a.func1(11,3));
System.out.println(&quot;1-8=&quot; + a.func1(1,8));

System.out.println(&quot;-----------------------&quot;);
B b = new B();
System.out.println(&quot;11-3=&quot; + b.func1(11,3)); //发生错误
System.out.println(&quot;1-8=&quot; + b.func1(1,8)); //发生错误
System.out.println(&quot;11+3+9=&quot; + b.func2(11,3));
</code></pre>
<p>我们发现原来运行正常的相减功能发生了错误，原因就是 class B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但是整个继承体系的复用性差，特别是运行多态比较频繁的时候。</p>
<p>解决方法：</p>
<p>通常的做法是，让父类和子类都继承一个更通用的类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。</p>
<img src="liskov_substitution_principle1.png" width="300">

<pre><code class="java">class Base &#123;// 把更加基础的方法和成员写在 Base 类
&#125;

class A extends Base&#123;
    public int func1(int num1, int num2) &#123;
        return num1-num2;
    &#125;
&#125;

class B extends Base &#123;
    // 如果 B 需要使用 A 类的方法，使用组合关系
    private A a = new A();
    public int func1(int a, int b) &#123;
        return a + b;
    &#125;
    public int func2(int a, int b) &#123;
        return func1(a, b) + 9;
    &#125;
    public int func3(int a, int b) &#123;
        return this.a.func1(a, b);
    &#125;
&#125;

A a = new A();
System.out.println(&quot;11-3=&quot; + a.func1(11,3));
System.out.println(&quot;1-8=&quot; + a.func1(1,8));

System.out.println(&quot;-----------------------&quot;);
B b = new B();
// 因为 class B 不再继承 class A，因此调用者不会再认为 func1 是求减法
System.out.println(&quot;11+3=&quot; + b.func1(11,3));
System.out.println(&quot;1+8=&quot; + b.func1(1,8));
System.out.println(&quot;11+3+9=&quot; + b.func2(11,3));
System.out.println(&quot;11-3=&quot; + b.func3(11,3));
System.out.println(&quot;1-8=&quot; + b.func3(1,8));
</code></pre>
<h1 id="5-开闭原则（Open-Closed-Principle）"><a href="#5-开闭原则（Open-Closed-Principle）" class="headerlink" title="5.开闭原则（Open Closed Principle）"></a>5.开闭原则（Open Closed Principle）</h1><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol>
<li>开闭原则是编程中最基础、最重要的设计原则</li>
<li>一个软件实体，如类、模块和函数，应该对扩展开放（对提供方），对修改关闭（对使用方）。也就是说，用抽象构建框架，用实现扩展细节。</li>
<li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li>
<li>编程中遵循其他原则以及使用设计模式的目的，就是遵循开闭原则。</li>
</ol>
<h2 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h2><p>完成一个画图形的功能，类图设计如下：<br><img src="open_closed_principle1.png" width="500"></p>
<p><i>Example 1.</i></p>
<pre><code class="java">public class OpenClosed &#123;
    public static void main(String[] args) &#123;
        GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle());
        graphicEditor.drawShape(new Circle());
        graphicEditor.drawShape(new Triangle()); 
    &#125;
&#125;

// 用于绘图的类[使用方]
class GraphicEditor &#123;
    // 接收 Shape 对象，根据 type 的值绘制不同的图形
    public void drawShape(Shape s) &#123;
        if (s.m_type == 1) &#123;
            drawRectangle(s);
        &#125; else if (s.m_type == 2) &#123;
            drawCircle(s);
        &#125; else if (s.m_type == 3) &#123; // 使用方需要添加新的逻辑
            drawTriangle(s);
        &#125;
    &#125;

    public void drawRectangle(Shape r) &#123;
        System.out.println(&quot;Draw Rectangle&quot;);
    &#125;

    public void drawCircle(Shape c) &#123;
        System.out.println(&quot;Draw Circle&quot;);
    &#125;

    // 添加绘制三角形的方法
    public void drawTriangle(Shape t) &#123;
        System.out.println(&quot;Draw Triangle&quot;);
    &#125;
&#125;

class Shape &#123;
    int m_type;
&#125;

class Rectangle extends Shape &#123;
    Rectangle() &#123;
        super.m_type = 1;
    &#125;
&#125;

class Circle extends Shape &#123;
    Circle() &#123;
        super.m_type = 2;
    &#125;
&#125;

// 新增画三角形
class Triangle extends Shape &#123;
    Triangle() &#123;
        super.m_type = 3;
    &#125;
&#125;
</code></pre>
<p>Example 1 的优缺点：</p>
<ol>
<li>优点是比较好理解，简单易操作；</li>
<li>缺点是违反了设计模式的开闭原则：对扩展开放，对修改关闭，即当我们给类增加新功能的时候，尽量不修改代码，或尽可能少的修改代码。</li>
<li>比如需要增加一个图形种类：三角形，则要修改的地方很多。</li>
</ol>
<p>改进思路分析：</p>
<p>把 Shape 类做成抽象类，并提供一个抽象的 draw 方法，让子类去实现。这样我们有新的图形种类时，只需要让新的图形继承 Shape，并实现 draw 方法即可。</p>
<p><i>Example 2.</i></p>
<pre><code class="java">public class OpenClosed &#123;
    public static void main(String[] args) &#123;
        GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle());
        graphicEditor.drawShape(new Circle());
        graphicEditor.drawShape(new Triangle());
        graphicEditor.drawShape(new AnotherShape());
    &#125;
&#125;

// 用于绘图的类[使用方]
class GraphicEditor &#123;
    // 接收 Shape 对象，根据 type 的值绘制不同的图形
    public void drawShape(Shape s) &#123;
        s.draw(); // 新增 Shape 时使用方不需要做任何修改
    &#125;
&#125;

abstract class Shape &#123;
    int m_type;
    public abstract void draw(); // 抽象方法
&#125;

class Rectangle extends Shape &#123;
    Rectangle() &#123;
        super.m_type = 1;
    &#125;
    @Override
    public void draw() &#123;
        System.out.println(&quot;Draw Rectangle&quot;);
    &#125;
&#125;

class Circle extends Shape &#123;
    Circle() &#123;
        super.m_type = 2;
    &#125;
    @Override
    public void draw() &#123;
        System.out.println(&quot;Draw Circle&quot;);
    &#125;
&#125;

class Triangle extends Shape &#123;
    Triangle() &#123;
        super.m_type = 3;
    &#125;
    @Override
    public void draw() &#123;
        System.out.println(&quot;Draw Triangle&quot;);
    &#125;
&#125;

// 新增一个图形
class AnotherShape extends Shape &#123;
    AnotherShape() &#123;
        super.m_type = 4;
    &#125;
    @Override
    public void draw() &#123;
        System.out.println(&quot;Draw AnotherShape&quot;);
    &#125;
&#125;
</code></pre>
<p>使用方的代码不需要修改：满足了开闭原则。</p>
<h1 id="6-迪米特法则（Demeter-Principle）"><a href="#6-迪米特法则（Demeter-Principle）" class="headerlink" title="6.迪米特法则（Demeter Principle）"></a>6.迪米特法则（Demeter Principle）</h1><h2 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol>
<li>一个对象应该对其他对象保持最少的了解。</li>
<li>类与类关系越密切，耦合度越大。</li>
<li>迪米特法则又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类内部，对外除了提供 public 方法，不泄漏任何信息。</li>
<li>迪米特法则还有一个更简单的定义：<strong>只与直接朋友通信</strong>。</li>
<li>直接朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多：依赖，关联，组合，聚合等。其中，我们称出现<strong>成员变量，方法参数，方法返回值</strong>中的类为直接朋友，而出现在局部变量中的类不是直接朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li>
</ol>
<h2 id="应用实例-5"><a href="#应用实例-5" class="headerlink" title="应用实例"></a>应用实例</h2><p>学校下属有总部和各学院，现要求打印出学校总部所有员工 ID 和各学院所有员工 ID。</p>
<p><i>Example 1.</i></p>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;

public class Demeter &#123;
    public static void main(String[] args) &#123;
        SchoolManager schoolManager = new SchoolManager();
        schoolManager.printAllEmployee(new CollegeManager());
    &#125;
&#125;

class Employee &#123;
    private String id;
    // Getter and Setter
&#125;

class CollegeEmployee &#123;
    private String id;
    // Getter and Setter
&#125;

// 学院管理类
class CollegeManager &#123;
    // 返回学院的所有员工（模拟）
    public List&lt;CollegeEmployee&gt; getAllEmployee() &#123;
        List&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;();
        for (int i=0; i&lt;10; i++) &#123;
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId(&quot;CollegeEmployeeID=&quot;+i);
            list.add(emp);
        &#125;
        return list;
    &#125;
&#125;

/**
 * 学校管理类
 * 分析 SchoolManager 的直接朋友：
 *  1. Employee 方法返回值
 *  2. CollegeManager 方法参数
 * CollegeEmployee 不是 SchoolManager 的直接朋友，而是一个陌生类，违反了迪米特法则
 */
class SchoolManager &#123;
    // 返回学校总部的员工（模拟）
    public List&lt;Employee&gt; getAllEmployee() &#123;
        List&lt;Employee&gt; list = new ArrayList&lt;&gt;();
        for (int i=0; i&lt;5; i++) &#123;
            Employee emp = new Employee();
            emp.setId(&quot;SchoolEmployeeID=&quot;+i);
            list.add(emp);
        &#125;
        return list;
    &#125;
    // 输出学校总部和学院员工的信息(id)
    void printAllEmployee(CollegeManager sub) &#123;
        // 分析问题：
        // CollegeEmployee 以局部变量的形式出现，不是 SchoolManager 的直接朋友
        // 违反了迪米特法则
        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();
        System.out.println(&quot;============College Employee============&quot;);
        for(CollegeEmployee emp: list1) &#123;
            System.out.println(emp.getId());
        &#125;
        List&lt;Employee&gt; list2 = this.getAllEmployee();
        System.out.println(&quot;============School Employee============&quot;);
        for(Employee emp: list2) &#123;
            System.out.println(emp.getId());
        &#125;
    &#125;
&#125;
</code></pre>
<p>分析和改进：</p>
<ol>
<li>Example 1 设计的问题在于：SchoolManager 中，CollegeEmployee 以局部变量的形式出现，不是 SchoolManager 的直接朋友；</li>
<li>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。</li>
<li>改进代码如下：</li>
</ol>
<p><i>Example 2.</i></p>
<pre><code class="java">// 学院管理类
class CollegeManager &#123;
    // 返回学院的所有员工（模拟）
    public List&lt;CollegeEmployee&gt; getAllEmployee() &#123;
        List&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;();
        for (int i=0; i&lt;10; i++) &#123;
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId(&quot;CollegeEmployeeID=&quot;+i);
            list.add(emp);
        &#125;
        return list;
    &#125;
    // 输出所有学院员工的信息(id)
    public void printAllEmployee() &#123;
        List&lt;CollegeEmployee&gt; list1 = this.getAllEmployee();
        System.out.println(&quot;============College Employee============&quot;);
        for(CollegeEmployee emp: list1) &#123;
            System.out.println(emp.getId());
        &#125;
    &#125;
&#125;

// 学校管理类
class SchoolManager &#123;
    // 返回学校总部的员工（模拟）
    public List&lt;Employee&gt; getAllEmployee() &#123;
        List&lt;Employee&gt; list = new ArrayList&lt;&gt;();
        for (int i=0; i&lt;5; i++) &#123;
            Employee emp = new Employee();
            emp.setId(&quot;SchoolEmployeeID=&quot;+i);
            list.add(emp);
        &#125;
        return list;
    &#125;
    // 输出学校总部和学院员工的信息(id)
    void printAllEmployee(CollegeManager sub) &#123;
        // 改进：将输出学院员工的方法封装到 CollegeManager 中
        sub.printAllEmployee();

        List&lt;Employee&gt; list2 = this.getAllEmployee();
        System.out.println(&quot;============School Employee============&quot;);
        for(Employee emp: list2) &#123;
            System.out.println(emp.getId());
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="注意事项和细节-2"><a href="#注意事项和细节-2" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h2><ol>
<li>迪米特法则的核心是降低类之间的耦合。</li>
<li>但是注意：由于每个类都减少了不必要的依赖，因为迪米特法则只是要求降低类之间（对象间）的耦合关系，并不是要求完全没有依赖关系。</li>
</ol>
<h1 id="7-合成复用原则（Composite-Reuse-Principle）"><a href="#7-合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="7.合成复用原则（Composite Reuse Principle）"></a>7.合成复用原则（Composite Reuse Principle）</h1><h2 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>继承：<br><img src="composite_reuse_principle1.png" width="300"></p>
<p>使用以下三种方式替代：</p>
<table width="100%">
<tr>
<td>1. 依赖：
<img src="composite_reuse_principle2.png" width="150"></td>
<td>2. 聚合：
<img src="composite_reuse_principle3.png" width="150"></td>
<td>3. 组合：
<img src="composite_reuse_principle4.png" width="150"></td>
</tr>
</table>

<h1 id="小结：设计原则的核心思想"><a href="#小结：设计原则的核心思想" class="headerlink" title="小结：设计原则的核心思想"></a>小结：设计原则的核心思想</h1><ol>
<li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>为了交互对象之间的松耦合设计而努力。</li>
</ol>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2022/11/21/Cucumber-%E5%AE%98%E6%96%B9%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%95%E8%A8%80/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          Cucumber 官方指南（一）引言
        
      </div>
    </a>
  
  
    <a href="/2022/08/06/GIT-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">GIT 常用命令</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=设计模式：七大设计原则 - 杜圆圆的学习笔记&url=https://dquaner.github.io/2022/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=设计模式：七大设计原则 - 杜圆圆的学习笔记&u=https://dquaner.github.io/2022/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=设计模式：七大设计原则 - 杜圆圆的学习笔记&url=https://dquaner.github.io/2022/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>












</div>
                </section>
            </section>

            
            <aside class="sidebar sidebar-search-fix">
                

    <div class="search">
    <div class="has-icon-right">
        <input type="text" class="form-input" id="search" placeholder="SEARCH" autocomplete="off">
        <div class="form-icon">
            <box-icon name='search' color="#3c4859"></box-icon>
        </div>
    </div>
    <div class="search-result" id="search-ps"></div>
</div>


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/devOps/">devOps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/">测试开发</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cucumber/" rel="tag">Cucumber</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ELK/" rel="tag">ELK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gatling/" rel="tag">Gatling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Monitoring/" rel="tag">Monitoring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentry/" rel="tag">Sentry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2022/11/21/Cucumber-%E5%AE%98%E6%96%B9%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%95%E8%A8%80/">Cucumber 官方指南（一）引言</a>
          </li>
        
          <li>
            <a href="/2022/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">设计模式：七大设计原则</a>
          </li>
        
          <li>
            <a href="/2022/08/06/GIT-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">GIT 常用命令</a>
          </li>
        
          <li>
            <a href="/2022/06/01/Gatling-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E5%9B%9B%EF%BC%89Guides/">Gatling 官方文档（四）Guides</a>
          </li>
        
          <li>
            <a href="/2022/06/01/Gatling-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%88%E4%B8%89%EF%BC%89Reference/">Gatling 官方文档（三）Reference</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            杜圆圆的学习笔记 &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1637200696663.js"></script>


<script src="/dist/custom.js?1637200696663.js"></script>









</body>

</html>