<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>Maven POM Reference 官方文档 | 杜圆圆的学习笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    
        <meta property="algolia:search" data-application-id="QVZKZA7CCN" data-api-key="3247c59b2591077db39388602665c9c2" data-index-name="my_blog">
    

    

    
    <link rel="icon" href="/images/icon-dyy.jpeg">
    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1637200696663.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1637200696663.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = false
        window.aomori_search_algolia = true

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <a class="header-type-title" href="/">杜圆圆的学习笔记</a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/dquaner">
        <box-icon type='logo' name='github'></box-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-cldroa5vj001l36a848qa7z1z" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      Maven POM Reference 官方文档
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2021-11-21T11:13:45.000Z" itemprop="datePublished">2021-11-21</time>
</div>

            
            <div class="article-category">
                <a class="article-category-link" href="/categories/Java/">Java</a>
            </div>
            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maven/" rel="tag">maven</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://maven.apache.org/pom.html">POM Reference</a><br>Last Published: 2023-01-23</p>
</blockquote>
<h1 id="1-POM-简介"><a href="#1-POM-简介" class="headerlink" title="1. POM 简介"></a>1. POM 简介</h1><h2 id="1-1-什么是POM？"><a href="#1-1-什么是POM？" class="headerlink" title="1.1 什么是POM？"></a>1.1 什么是POM？</h2><p>POM 即 “Project Object Model”，它用 XML 表示一个 maven 项目并保存在 <code>pom.xml</code> 文件中。 谈论一个 Maven 项目，不仅仅是指代码的集合，而是包括配置文件、相关开发人员和他们的角色、缺陷跟踪系统、组织和许可、项目 URL、项目依赖以及所有赋予代码生命的其他部分。它像一个与项目有关的所有事物的一站式商店。事实上，在 Maven 世界中，一个项目甚至不需要包含任何代码，只需要一个 <code>pom.xml</code> 文件。</p>
<span id="more"></span>

<h2 id="1-2-POM-概述"><a href="#1-2-POM-概述" class="headerlink" title="1.2 POM 概述"></a>1.2 POM 概述</h2><p>下面列出了 <code>&lt;project&gt;</code> 的直接子元素。注意，<code>modelVersion</code> 指定为 4.0.0。这是当前唯一受支持的 POM 版本，并且始终是必需的。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
  &lt;!-- 基础信息 --&gt;
  &lt;groupId&gt;...&lt;/groupId&gt;
  &lt;artifactId&gt;...&lt;/artifactId&gt;
  &lt;version&gt;...&lt;/version&gt;
  &lt;packaging&gt;...&lt;/packaging&gt;
  &lt;dependencies&gt;...&lt;/dependencies&gt;
  &lt;parent&gt;...&lt;/parent&gt;
  &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;
  &lt;modules&gt;...&lt;/modules&gt;
  &lt;properties&gt;...&lt;/properties&gt;
 
  &lt;!-- 构建设置 --&gt;
  &lt;build&gt;...&lt;/build&gt;
  &lt;reporting&gt;...&lt;/reporting&gt;
 
  &lt;!-- 更多项目信息 --&gt;
  &lt;name&gt;...&lt;/name&gt;
  &lt;description&gt;...&lt;/description&gt;
  &lt;url&gt;...&lt;/url&gt;
  &lt;inceptionYear&gt;...&lt;/inceptionYear&gt;
  &lt;licenses&gt;...&lt;/licenses&gt;
  &lt;organization&gt;...&lt;/organization&gt;
  &lt;developers&gt;...&lt;/developers&gt;
  &lt;contributors&gt;...&lt;/contributors&gt;
 
  &lt;!-- 环境设置 --&gt;
  &lt;issueManagement&gt;...&lt;/issueManagement&gt;
  &lt;ciManagement&gt;...&lt;/ciManagement&gt;
  &lt;mailingLists&gt;...&lt;/mailingLists&gt;
  &lt;scm&gt;...&lt;/scm&gt;
  &lt;prerequisites&gt;...&lt;/prerequisites&gt;
  &lt;repositories&gt;...&lt;/repositories&gt;
  &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;
  &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;
  &lt;profiles&gt;...&lt;/profiles&gt;
&lt;/project&gt;
</code></pre>
<h1 id="2-基础信息"><a href="#2-基础信息" class="headerlink" title="2. 基础信息"></a>2. 基础信息</h1><p>POM 包含项目相关的所有<strong>必要信息</strong>，以及在构建项目过程中使用的插件配置。POM 声明了“谁”、“什么”和“哪里”，而构建生命周期声明了“何时”和“如何”，这并不是说 POM 不能影响生命周期的流程 —— 它可以。例如，通过配置 <code>maven-antrun-plugin</code>，可以将 Apache Ant 任务嵌入到 POM 中。然而，它最终是一个声明：<code>build.xml</code> 准确地告诉 Ant 它运行时要做什么（程序性），而 POM 则是声明它的配置（声明性）。如果某些外力导致构建生命周期跳过 Ant 插件的执行，不会影响已执行的插件发挥作用，这与 <code>build.xml</code> 文件不同：后续的任务几乎总是依赖于在它之前执行的行。</p>
<p><i>示例：</i></p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
  &lt;artifactId&gt;my-project&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
&lt;/project&gt;
</code></pre>
<h2 id="2-1-坐标系统"><a href="#2-1-坐标系统" class="headerlink" title="2.1 坐标系统"></a>2.1 坐标系统</h2><p>上面定义的 POM 是 Maven 要求的<strong>最低限度</strong>，<code>groupId:artifactId:version</code> 都是<strong>必填字段</strong>（如果 groupId 和 version 是从父级继承而来的，则不需要显式定义它们 —— 稍后将详细介绍 <a href="#2.3.2-%E7%BB%A7%E6%89%BF">POM 继承</a>）。这三个字段像 Maven 项目的坐标系统一样，标志着 Maven 库中的特定位置：</p>
<ul>
<li><p><strong>groupId:</strong> </p>
<ul>
<li><p>在组织或项目中通常是唯一的，例如，所有 Maven 核心组件都应该位于 <code>org.apache.maven</code> 下。</p>
</li>
<li><p>不一定使用 <code>.</code> 表示法，例如，junit 项目使用 <code>-</code> 。</p>
</li>
<li><p>请注意，<code>.</code> 标记的 <code>groupId</code> 不必与项目包含的包​​结构相对应，但这是一个很好的做法。当存储在存储库中时，group 的行为很像操作系统中 Java 打包结构。这些 <code>.</code> 被操作系统特定的目录分隔符（比如 Unix 中的 <code>/</code> ）替换，成为 Maven 库中的相对目录结构。</p>
</li>
<li><p>上述示例中，<code>org.codehaus.mojo</code> 位于 <code>$M2_REPO/org/codehaus/mojo</code> 目录中。</p>
</li>
</ul>
</li>
<li><p><strong>artifactId:</strong> </p>
<ul>
<li><p>通常是项目的名称。</p>
</li>
<li><p>与 <code>groupId</code> 一起创建了一个 key ，将该项目与其他项目区分开。</p>
</li>
<li><p>与 <code>groupId</code> 一起定义了组件在 Maven 库中的存储位置。</p>
</li>
<li><p>上述示例中，<code>my-project</code> 位于 <code>$M2_REPO/org/codehaus/mojo/my-project</code> 目录中。</p>
</li>
</ul>
</li>
<li><p><strong>version:</strong> </p>
<ul>
<li><p>命名拼图的最后一块。</p>
</li>
<li><p><code>groupId:artifactId</code> 能够表示单个项目，但它们无法描述我们正在谈论该项目的哪个版本。简而言之，应该对代码更改进行版本控制，并且 <code>version</code> 元素用于控制版本保持一致。它还用于在 Maven 库中将项目按版本区分开。 </p>
</li>
<li><p>上述示例中，<code>my-project</code> 的 1.0 版位于 <code>$M2_REPO/org/codehaus/mojo/my-project/1.0</code> 目录中。</p>
</li>
</ul>
</li>
</ul>
<p>上面给出的三个元素指向<strong>一个项目的一个特定版本</strong>，让 Maven 知道我们正在与”谁”打交道，以及我们需要它们软件生命周期的“何时”。</p>
<h2 id="2-2-打包方式"><a href="#2-2-打包方式" class="headerlink" title="2.2 打包方式"></a>2.2 打包方式</h2><p>有了 <code>groupId:artifactId:version</code> 坐标体系，还有一个更标准的元素给我们一个真正完整的内容：<code>&lt;packaging&gt;</code> 。上述示例中定义的 <code>org.codehaus.mojo:my-project:1.0</code> 将被打包为一个 <code>jar</code>。我们可以通过声明 <code>&lt;packaging&gt;</code> 来使它被打包成一个 <code>war</code>：</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;packaging&gt;war&lt;/packaging&gt;
  ...
&lt;/project&gt;
</code></pre>
<p>当没有声明 <code>&lt;packaging&gt;</code> 时，Maven 默认为 <code>jar</code>。目前核心的 <code>&lt;packaging&gt;</code> 值为：<code>pom</code>、<code>jar</code>、<code>maven-plugin</code>、<code>ejb</code>、<code>war</code>、<code>ear</code>、<code>rar</code>。这些包类型定义了一系列的默认构建目标，这些目标为一个特定的包结构在每个相应的构建生命周期阶段执行。更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://maven.apache.org/ref/3.8.4/maven-core/default-bindings.html"> Plugin Bindings for default Lifecycle Reference </a>。</p>
<h2 id="2-3-POM-关系"><a href="#2-3-POM-关系" class="headerlink" title="2.3 POM 关系"></a>2.3 POM 关系</h2><p>Maven 的一个强大方面是它对项目关系的处理：包括依赖(以及传递依赖)，继承，以及聚合(多模块项目)。</p>
<p>依赖管理有着“依赖琐碎，并且所有事情都一团糟”的传统。随着依赖树变得庞大而复杂，”Jarmageddon” 很快就会发生，接下来是 “Jar Hell” ：即系统的依赖项版本不等同于开发所使用的版本，要么是给定了错误的版本，要么是类似命名的 jars 之间的冲突版本。</p>
<p>Maven 通过一个<strong>公共的本地存储库</strong>解决了这两个问题，从公共的本地存储库中可以正确链接项目、版本和你需要的一切。</p>
<h3 id="2-3-1-依赖"><a href="#2-3-1-依赖" class="headerlink" title="2.3.1 依赖"></a>2.3.1 依赖</h3><p>POM 的基石是它的<a target="_blank" rel="noopener" href="https://maven.apache.org/ref/3.8.4/maven-model/maven.html#class_dependency">依赖</a>列表。大多数项目依赖于其他项目才能正确构建和运行，Maven 管理依赖列表，在编译以及其他需要这些依赖的时候下载并链接它们。Maven 还有一个额外的好处：引入这些依赖的依赖（传递依赖），允许你的依赖列表只关注你的项目所需的依赖。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.12&lt;/version&gt;
      &lt;type&gt;jar&lt;/type&gt;
      &lt;scope&gt;test&lt;/scope&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    ...
  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</code></pre>
<ul>
<li><p><strong>groupId、artifactId、version</strong></p>
<p>你会经常看到这些元素，这三个元素一起用于计算某个特定项目的 Maven 坐标，并将其划定为项目的依赖项。这个计算的目的是选择一个匹配所有声明的依赖版本（由于传递依赖，同一个依赖可以存在多个声明）。这些值应该是：  </p>
<ul>
<li>groupId，artifactId：直接对应依赖的坐标，</li>
<li>version：依赖版本需求规范，用于计算依赖的有效版本。  </li>
</ul>
<p>由于依赖是通过 Maven 坐标来描述的，你可能会想：“这意味着我的项目只能依赖 Maven 组件”，答案是，“当然，但这是一件好事”。这迫使您只依赖 Maven 可以管理的依赖项。不幸的是，有时<strong>无法从中央 Maven 库下载项目</strong>，例如，一个项目可能依赖于一个具有闭源许可证的 jar，它不能存储在中央库中。有三种方法可以处理这种情况：</p>
<ol>
<li><p>使用安装插件在本地安装依赖，这是最简单的一种方法。<br>例如：<code>mvn install:install-file -Dfile=non-maven-proj.jar -DgroupId=some.group -DartifactId=non-maven-proj -Dversion=1 -Dpackaging=jar</code><br>请注意，地址仍然是必需的，只是这次您使用命令行，安装插件会使用给定的地址为你创建一个 POM。</p>
</li>
<li><p>创建你自己的库并部署，这对拥有内网并且需要让每个人保持同步的公司来说是最受欢迎的一种方法。<br>使用 Maven 目标：<code>deploy:deploy-file</code>，它类似于 <code>install:install-file</code>（阅读 plugin’s goal 页面了解更多信息）。</p>
</li>
<li><p>将依赖的 scope 设置为 <code>system</code> 并定义一个 <code>systemPath</code>，但不建议这样做。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>classifier</strong></p>
<p>区分由相同 POM 构建但实际内容不同的组件。它是可选的任意的字符串，附加在组件名称的版本号之后。<br>例如一个项目同时提供面向 Java 11 以及 Java 1.8 的组件，那么第一个组件可以将 <code>&lt;classifier&gt;</code> 配置为 <code>jdk11</code>，第二个组件配置为 <code>jdk8</code>，以便用户可以选择使用哪一个。<br>另一个常见用例是将项目的次要组件附加到项目的主要组件。如果你浏览 Maven 中央库，你会注意到 classifier <code>source</code> 和 <code>javadoc</code> 分别代表将项目源代码或API文档与项目类文件一起部署。</p>
</li>
</ul>
<ul>
<li><p><strong>type</strong></p>
<p>指定依赖的类型，默认为 <code>jar</code>。虽然它通常表示依赖文件的扩展名，但情况并非总是如此：一个类型可以被映射到一个不同的扩展名或 classifier。类型通常与该依赖所使用的 <code>&lt;packaging&gt;</code> 相对应，但也不能完全确定。例如 <code>jar</code>, <code>ejb-client</code> 和 <code>test-jar</code>：查看 <a target="_blank" rel="noopener" href="https://maven.apache.org/ref/3.8.4/maven-core/artifact-handlers.html">default artifact handlers</a> 获取列表。但这不代表完整的列表，因为可以通过 <code>&lt;extensions&gt;</code> 为 <code>true</code> 的插件定义新的类型。</p>
</li>
</ul>
<ul>
<li><p><strong>scope</strong>  </p>
<p>指定依赖在什么任务（编译时、运行时、测试时等）的类路径中以及如何限制该依赖的传递性。有 5 种可用的 scope ：</p>
<ul>
<li>compile：默认值，compile 依赖在所有类路径（编译、运行、测试）中都可用，且 compile 依赖会传递给依赖当前项目的项目。</li>
<li>provided: 表示希望 JDK 或容器在项目运行时提供该依赖，provided 依赖仅在编译和测试类路径上可用，且不具传递性。</li>
<li>runtime: 表示该依赖不是项目编译所必需的，而是执行所必需的，runtime 依赖在运行和测试类路径中，不在编译类路径中。</li>
<li>test: 表示该依赖项不是应用程序正常使用所必须的，test 依赖仅适用于测试编译和执行阶段，不具传递性。</li>
<li>system: 类似于 provided ，除了必须提供显示包含依赖的 jar 包，system 依赖始终可用，不会去库中查找。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>systemPath</strong>  </p>
<p>仅当 <code>scope</code> 为 <code>system</code> 时才使用。否则，如果设置了此元素，会导致构建失败。路径必须是绝对路径，因此建议使用属性来指定特定于机器的路径（2.4小节会详细介绍属性），例如 <code>$&#123;java.home&#125;/lib</code>。由于 Maven 假定 system 依赖是先验安装的，因此不会再检查项目的存储库，而是检查指定文件是否存在。如果不存在，Maven 构建会失败并会建议你手动下载安装该依赖。</p>
</li>
</ul>
<ul>
<li><p><strong>optional</strong>  </p>
<p>让想要引用当前项目的其他项目知道，不需要这个标记为 optional 的依赖也可以正常工作。<br>例如，项目 A 依赖于 B 来编译一部分在运行时可能不会使用的代码，那么对整个项目来说，可能并不需要项目 B。所以如果项目 X 添加了项目 A 作为自己的依赖，是完全不需要安装依赖 B 的。如果 <code>=&gt;</code> 表示必需的依赖项，而 <code>--&gt;</code> 表示可选的，尽管在构建 A 时可能 <code>A=&gt;B</code>，但在构建 X 时可能 <code>X=&gt;A--&gt;B</code>。即依赖 B 不会传递给项目 X 。  </p>
</li>
</ul>
<p><strong>版本要求规范</strong></p>
<p>依赖的 <code>&lt;version&gt;</code> 元素定义了版本要求，用于计算依赖的版本。软要求可以被依赖图（依赖树）中同一个依赖的其他版本替换。硬要求强制要求一个特定版本或多个版本并覆盖软要求。如果有依赖没有找到满足所有硬要求的版本，那么构建会失败。</p>
<p>版本要求具有以下语法：</p>
<p><code>1.0</code>：软要求，如果依赖树中没有其他版本早于 1.0 出现，则使用 1.0 版本。<br><code>[1.0]</code>：硬要求，只能使用 1.0 版本。<br><code>(,1.0]</code>：硬要求，可以使用任何 &lt;= 1.0 的版本。<br><code>[1.2,1.3]</code>：硬要求，可以使用 1.2 和 1.3 之间的任何版本。<br><code>[1.0,2.0)</code>：硬要求，可以使用任何 &gt;= 1.0 且 &lt; 2.0 的版本。<br><code>[1.5,)</code>：硬要求，可以使用任何 &gt;= 1.5 的版本。<br><code>(,1.0],[1.2,)</code>：硬要求，可以使用任何 &lt;= 1.0 或 &gt;= 1.2 的版本的；多个要求用逗号分隔。<br><code>(,1.1),(1.1,)</code>：硬要求，可以使用除了 1.1 之外的任何版本；例如 1.1 版本有严重的漏洞的场景。</p>
<p>Maven 会选择满足所有硬要求的该依赖的最高版本。</p>
<p><strong>版本顺序规范</strong></p>
<p>如果版本字符串是语法正确的 <a target="_blank" rel="noopener" href="https://semver.org/spec/v1.0.0.html">Semantic Versioning 1.0.0</a> 版本号，那么几乎在所有情况下，版本比较都遵循该规范中概述的优先规则。语法正确的版本号是常见的字母数字 ASCII 字符串，例如 <code>2.15.2-alpha</code> 。更准确地说，要比较的两个版本号都应该与 Semantic Versioning 规范中 BNF 语法的 “valid semver” 产生式相匹配。Maven 不考虑该规范隐含的任何语义。</p>
<p><u>重要提示</u>：仅适用于 Semantic Versioning 1.0.0。 Maven 版本顺序规范与 Semantic Versioning 2.0.0 不兼容。特别是，Maven 不会对加号或构建标识符进行特殊处理。</p>
<p>当版本字符串不遵循语义版本控制时，则需要一组更复杂的规则：Maven 坐标会在点 (<code>.</code>)、连字符 (<code>-</code>) 以及<code>数字和字符之间的转换</code>处分割，分割符会被保留下来，并且在后续过程对顺序产生影响。<code>数字和字符之间的转换</code>会被替换为连字符“<code>-</code>”。空标记会被替换为“<code>0</code>”。处理后就产生了一系列带有“<code>.</code>”或“<code>-</code>”前缀的版本数字（即数字tokens）和版本限定符（即非数字tokens）。</p>
<p>拆分和替换示例：</p>
<p><code>1-1.foo-bar1baz-.1</code> -&gt; <code>1-1.foo-bar-1-baz-0.1</code></p>
<p>然后，修剪版本末尾的“空”值（<code>0</code>、<code>“”</code>、“<code>fianl</code>”、“<code>ga</code>”），从后向前在每个剩余的连字符”<code>-</code>“处重复此过程。</p>
<p>修剪示例：</p>
<p><code>1.0.0</code> -&gt; <code>1</code><br><code>1.ga</code> -&gt; <code>1</code><br><code>1.final</code> -&gt; <code>1</code><br><code>1.0</code> -&gt; <code>1</code><br><code>1.</code> -&gt; <code>1</code><br><code>1-</code> -&gt; <code>1</code><br><code>1.0.0-foo.0.0</code> -&gt; <code>1-foo</code><br><code>1.0.0-0.0.0</code> -&gt; <code>1</code></p>
<p>版本顺序是这一系列带前缀的 tokens 的字典顺序，为较短的版本填充足够的“空”值以达到与较长的版本相同的长度。填充的“空”值取决于另一个版本的前缀：如果前缀为“<code>.</code>”则填充 <code>0</code>，如果前缀为“<code>-</code>”则填充 <code>“”</code>。带前缀的 token 的顺序是：</p>
<ul>
<li><p>如果前缀相同，则比较 token ：</p>
<ul>
<li><p>数字 tokens 具有自然顺序。</p>
</li>
<li><p>非数字 tokens（“qualifiers”）具有字母顺序，除了以下 tokens 按此顺序排在最前面：“<code>alpha</code>” &lt; “<code>beta</code>” &lt; “<code>milestone</code>” &lt; “<code>rc</code>” = “<code>cr</code>” &lt; “<code>snapshot</code>” &lt; “” = “<code>final</code>” = “<code>ga</code>” &lt; “<code>sp</code>”</p>
<ul>
<li>当直接后跟数字时，“<code>alpha</code>”、“<code>beta</code>” 和 “<code>milestone</code>” 限定符可以分别缩写为 “<code>a</code>”、“<code>b</code>” 和 “<code>m</code>”。</li>
</ul>
</li>
</ul>
</li>
<li><p>否则: “<code>.qualifier</code>” &lt; “<code>-qualifier</code>” &lt; “<code>-number</code>” &lt; “<code>.number</code>”</p>
</li>
</ul>
<p>最终结果示例：</p>
<p><code>1</code> &lt; <code>1.1</code>（数字填充）<br><code>1-snapshot</code> &lt; <code>1</code> &lt; <code>1-sp</code>（限定符填充）<br><code>1-foo2</code> &lt; <code>1-foo10</code>（正确地自动“切换”到数字顺序）<br><code>1.foo</code> &lt; <code>1-foo</code> &lt; <code>1-1</code> &lt; <code>1.1</code>（根据前缀不同的比较规则）<br><code>1.ga</code> = <code>1-ga</code> = <code>1-0</code> = <code>1.0</code> = <code>1</code>（删除末尾的“空”值）<br><code>1-sp</code> &gt; <code>1-ga</code><br><code>1-sp.1</code> &gt; <code>1-ga.1</code><br><code>1-sp-1</code> &lt; <code>1-ga-1</code> = <code>1-1</code>（每个连字符处处理的末尾“空”值）<br><code>1-a1</code> = <code>1-alpha-1</code></p>
<p>注意：与某些设计文档中所述的相反，对于版本顺序，对快照版本的处理与发布版本或任何其他限定符的处理方式没有区别。</p>
<p>注意：已知 <code>2.0-rc1</code> &lt; <code>2.0</code>，那么版本要求 <code>[1.0, 2.0)</code> 就不包括 <code>2.0</code> 但包括 <code>2.0-rc1</code>，这可能与大部分开发者所想的不同。另外，Gradle 对此的解释与 Maven 有所不同，就会导致相同的 POM 产生的依赖树不同，因此如果想限定依赖版本为 <code>1.*</code> ，那么最好的方式为 <code>[1, 1.999999)</code> 。</p>
<p><strong>版本顺序测试</strong></p>
<p>Maven 发布版包括一个检查版本顺序的工具，你可以自己尝试一下：</p>
<pre><code>java -jar $&#123;MAVEN_HOME&#125;/lib/maven-artifact-3.8.7.jar [versions...]
</code></pre>
<p><i>示例：</i></p>
<pre><code class="sh">$ java -jar ./lib/maven-artifact-3.8.7.jar 1 2 1.1
Display parameters as parsed by Maven (in canonical from and as a list of tokens) and comparison result:
1. 1 -&gt; 1; tokens: [1]
   1 &lt; 2
2. 2 -&gt; 2; tokens: [2]
   2 &gt; 1.1
3. 1.1 -&gt; 1.1; tokens: [1, 1]
</code></pre>
<p><strong>排除项</strong><br>排除项告诉 Maven 不要引入此依赖的依赖（换句话说，其传递依赖）。例如，<code>maven-embedder</code> 依赖 <code>maven-core</code>，我们不想使用它或它的依赖，则可以将其添加为 <code>&lt;exclusion&gt;</code>：</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;artifactId&gt;maven-embedder&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
          &lt;artifactId&gt;maven-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    ...
  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</code></pre>
<p>裁剪依赖的传递依赖有时也很有用。依赖可能具有错误指定的范围，或者与项目中的其他依赖冲突。使用通配符排除可以轻松排除一个依赖的所有传递依赖。在下面的示例中，你可能正在使用 <code>maven-embedder</code> 并且想自己管理项目需要的依赖项，因此你可以裁剪掉所有传递依赖：</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;artifactId&gt;maven-embedder&lt;/artifactId&gt;
      &lt;version&gt;3.1.0&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;*&lt;/groupId&gt;
          &lt;artifactId&gt;*&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    ...
  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</code></pre>
<ul>
<li>exclusions: 排除项包括一个或多个 <code>exclusion</code> 元素，每一个 <code>exclusion</code> 包括 <code>groupId</code> 和 <code>artifactId</code> 来指向需要排除的依赖。和 <code>optional</code> 有些不同，<code>optional</code> 的依赖可能会也可能不会被安装和使用；<code>exclusions</code> 积极地在依赖树中将自己删除。</li>
</ul>
<h3 id="2-3-2-继承"><a href="#2-3-2-继承" class="headerlink" title="2.3.2 继承"></a>2.3.2 继承</h3><p>Maven 的另一个强大之处是给构建管理带来了程序继承的概念。尽管在构建系统中可以模仿 Ant 继承之类的工具，Maven 在 POM 中显示地实现了项目继承。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
  &lt;artifactId&gt;my-parent&lt;/artifactId&gt;
  &lt;version&gt;2.0&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
&lt;/project&gt;
</code></pre>
<p>对父项目或聚合（多模块）项目来说，<code>packaging</code> 必须为 <code>pom</code>。这些类型定义了一系列与生命周期阶段绑定的目标，例如，如果你的 <code>packaging</code> 设置为 <code>jar</code>，那么在 <code>package</code> 阶段将会执行 <code>jar:jar</code> 目标。现在，我们可以在父 POM 中添加值，这些值将会被它的子 POM 继承。大部分父 POM 的元素会被它们的子 POM 继承，包括：</p>
<ul>
<li>groupId</li>
<li>version</li>
<li>description</li>
<li>url</li>
<li>inceptionYear</li>
<li>organization</li>
<li>licenses</li>
<li>developers</li>
<li>contributors</li>
<li>mailingLists</li>
<li>scm</li>
<li>issueManagement</li>
<li>ciManagement</li>
<li>properties</li>
<li>dependencyManagement</li>
<li>dependencies</li>
<li>repositories</li>
<li>pluginRepositories</li>
<li>build<ul>
<li>plugin executions with matching ids</li>
<li>plugin configuration</li>
<li>etc.</li>
</ul>
</li>
<li>reporting</li>
<li>profiles</li>
</ul>
<p>不会被继承的有：</p>
<ul>
<li>artifactId</li>
<li>name</li>
<li>prerequisites</li>
</ul>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
  &lt;parent&gt;
    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
    &lt;artifactId&gt;my-parent&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;relativePath&gt;../my-parent&lt;/relativePath&gt;
  &lt;/parent&gt;
 
  &lt;artifactId&gt;my-project&lt;/artifactId&gt;
&lt;/project&gt;
</code></pre>
<p>注意：<code>relativePath</code> 元素不是必须的，但是可以用来指定首先从该路径搜索该父项目，在搜索本地以及远程库之前。</p>
<p>继承的实践，查看 <a target="_blank" rel="noopener" href="https://svn.apache.org/viewvc/maven/pom/trunk/asf/pom.xml?view=markup">ASF</a> 或者 <a target="_blank" rel="noopener" href="https://svn.apache.org/viewvc/maven/pom/trunk/maven/pom.xml?view=markup">Maven</a> 父 POM 。</p>
<p><strong>超级 POM</strong></p>
<p>类似于面向对象编程中对象的继承，子 POMs 从父 POM 中继承了某些值。此外，就像 Java 对象最终都从 <code>java.lang.Object</code> 继承一样，所有 POM 都从一个基础的超级 POM 继承。下面是 Maven 3.5.4 的超级 POM ：</p>
<pre><code class="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;central&lt;/id&gt;
      &lt;name&gt;Central Repository&lt;/name&gt;
      &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;
 
  &lt;pluginRepositories&gt;
    &lt;pluginRepository&gt;
      &lt;id&gt;central&lt;/id&gt;
      &lt;name&gt;Central Repository&lt;/name&gt;
      &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
      &lt;releases&gt;
        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
      &lt;/releases&gt;
    &lt;/pluginRepository&gt;
  &lt;/pluginRepositories&gt;
 
  &lt;build&gt;
    &lt;directory&gt;$&#123;project.basedir&#125;/target&lt;/directory&gt;
    &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/classes&lt;/outputDirectory&gt;
    &lt;finalName&gt;$&#123;project.artifactId&#125;-$&#123;project.version&#125;&lt;/finalName&gt;
    &lt;testOutputDirectory&gt;$&#123;project.build.directory&#125;/test-classes&lt;/testOutputDirectory&gt;
    &lt;sourceDirectory&gt;$&#123;project.basedir&#125;/src/main/java&lt;/sourceDirectory&gt;
    &lt;scriptSourceDirectory&gt;$&#123;project.basedir&#125;/src/main/scripts&lt;/scriptSourceDirectory&gt;
    &lt;testSourceDirectory&gt;$&#123;project.basedir&#125;/src/test/java&lt;/testSourceDirectory&gt;
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;
      &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
      &lt;testResource&gt;
        &lt;directory&gt;$&#123;project.basedir&#125;/src/test/resources&lt;/directory&gt;
      &lt;/testResource&gt;
    &lt;/testResources&gt;
    &lt;pluginManagement&gt;
      &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt;
      &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
          &lt;version&gt;1.3&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.2-beta-5&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.8&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.5.3&lt;/version&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
 
  &lt;reporting&gt;
    &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/site&lt;/outputDirectory&gt;
  &lt;/reporting&gt;
 
  &lt;profiles&gt;
    &lt;!-- NOTE: The release profile will be removed from future versions of the super POM --&gt;
    &lt;profile&gt;
      &lt;id&gt;release-profile&lt;/id&gt;
 
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;performRelease&lt;/name&gt;
          &lt;value&gt;true&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
 
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin&gt;
            &lt;inherited&gt;true&lt;/inherited&gt;
            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
            &lt;executions&gt;
              &lt;execution&gt;
                &lt;id&gt;attach-sources&lt;/id&gt;
                &lt;goals&gt;
                  &lt;goal&gt;jar-no-fork&lt;/goal&gt;
                &lt;/goals&gt;
              &lt;/execution&gt;
            &lt;/executions&gt;
          &lt;/plugin&gt;
          &lt;plugin&gt;
            &lt;inherited&gt;true&lt;/inherited&gt;
            &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;
            &lt;executions&gt;
              &lt;execution&gt;
                &lt;id&gt;attach-javadocs&lt;/id&gt;
                &lt;goals&gt;
                  &lt;goal&gt;jar&lt;/goal&gt;
                &lt;/goals&gt;
              &lt;/execution&gt;
            &lt;/executions&gt;
          &lt;/plugin&gt;
          &lt;plugin&gt;
            &lt;inherited&gt;true&lt;/inherited&gt;
            &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;updateReleaseInfo&gt;true&lt;/updateReleaseInfo&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
 
&lt;/project&gt;
</code></pre>
<p>你可以查看超级 POM 如何影响你自己的 POM：创建一个最简单的 <code>pom.xml</code> ，并在命令行执行 <code>mvn help:effective-pom</code> 。</p>
<p><strong>依赖管理</strong></p>
<p>除了继承确切的高级别的元素，父 POM 可以配置子 POMs 的值并且传递依赖，其中一个例子就是 <code>dependencyManagement</code> 。</p>
<ul>
<li><p><strong>dependencyManagement:</strong>   </p>
<p>帮助管理所有子 POM 的依赖信息。如果 <code>my-parent</code> 项目使用 <code>dependencyManagement</code> 来定义一个依赖 <code>junit:junit:4.12</code>，那么继承此项目的子 POMs 只需要给定 <code>groupId</code> = <code>junit</code> 以及 <code>artifactId</code> = <code>junit</code>, Maven 会自动填充父 POM 设置的 <code>version</code> 。这种方法的好处是显而易见的：依赖的详细信息可以在一个地方被集中的配置，并传递给所有继承它的 POMs。注意，传递依赖的 <code>version</code> 和 <code>scope</code> 也会受 <code>dependencyManagement</code> 中指定的版本的控制，这可能会导致意外的后果。例如，你在项目中使用了 <code>dep1</code> 和 <code>dep2</code> 两个依赖，而 <code>dep2</code> 也依赖 <code>dep1</code> 并且需要一个特定的小版本才能正常工作。如果你使用 <code>dependencyManagement</code> 指定了一个更早的版本，<code>dep2</code> 会被强制使用该版本并导致失败。所以，你应该使用 <code>mvn dependency:tree</code> 谨慎的检查整个依赖树来避免此类问题。</p>
</li>
</ul>
<h3 id="2-3-3-聚合-或多模块"><a href="#2-3-3-聚合-或多模块" class="headerlink" title="2.3.3 聚合 (或多模块)"></a>2.3.3 聚合 (或多模块)</h3><p>多模块项目或聚合项目指的是一个项目中包含多个模块。模块是该 POM 列出的项目，并且作为组执行。一个打包方式为 <code>pom</code> 的项目可以通过将一系列项目列为 <code>module</code> 来聚合这些项目的构建，<code>module</code> 的值是这些项目的目录或 POM 文件的相对路径。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
  &lt;artifactId&gt;my-parent&lt;/artifactId&gt;
  &lt;version&gt;2.0&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
 
  &lt;modules&gt;
    &lt;module&gt;my-project&lt;/module&gt;
    &lt;module&gt;another-project&lt;/module&gt;
    &lt;module&gt;third-project/pom-example.xml&lt;/module&gt;
  &lt;/modules&gt;
&lt;/project&gt;
</code></pre>
<p>列出这些模块时，不需要考虑模块间的依赖关系；例如，模块的声明顺序并不重要。Maven 将对模块进行拓扑排序，以便始终在需要依赖的模块之前构建依赖。</p>
<p>聚合的实践，查看 <a target="_blank" rel="noopener" href="https://svn.apache.org/viewvc/maven/maven-3/trunk/pom.xml?view=markup">Maven</a> 或 <a target="_blank" rel="noopener" href="https://svn.apache.org/viewvc/maven/plugins/trunk/pom.xml?view=markup">Maven Core Plugins</a> 基础 POM’s 。</p>
<p><strong>继承与聚合</strong></p>
<p>继承和聚合通过一个单一的高级别的 POM 动态的控制构建，你可能会经常遇到即是父亲又是聚合的项目。例如，整个 Maven 核心通过一个单一的基础 POM <code>org.apache.maven:maven</code> 运行，所以可以通过一个单一的指令 <code>mvn compile</code> 构建 Maven 项目。但是一个父项目和一个聚合项目都是 POM 项目，它们不是同一个项目，不应该混淆。一个 POM 项目可以继承它聚合的任何模块，但不一定有这种情况；相反，一个 POM 项目也可以聚合没有继承它的项目。</p>
<h2 id="2-4-属性"><a href="#2-4-属性" class="headerlink" title="2.4 属性"></a>2.4 属性</h2><p>属性是了解 POM 基础的最后一部分内容。类似于 Ant 属性，Maven 属性也是值占位符。属性的值可以在 POM 中的任何地方使用符号 <code>$&#123;X&#125;</code> 访问，其中 <code>X</code> 是属性名称。或者它们可以作为默认值被插件使用，例如:</p>
<pre><code class="xml">&lt;project&gt;
  ...
  &lt;properties&gt;
    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;!-- 下面的 project.-properties 是 Maven 的保留项，将成为一个未来 POM 定义中的元素 --&gt;
    &lt;!-- 你自己的属性不要以 project. 开头 --&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; 
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
  &lt;/properties&gt;
  ...
&lt;/project&gt;
</code></pre>
<p>属性有 5 种不同的风格：</p>
<ol>
<li><p><code>env.X</code>：在变量前加上 “env.” 将返回 shell 的环境变量，例如，<code>$&#123;env.PATH&#125;</code> 返回 PATH 环境变量。<br>注意：虽然环境变量在 Windows 系统中非大小写敏感的，但在查找 POM 属性时是大小写敏感的。换句话说，即使 Windows shell 对 <code>%PATH%</code> 和 <code>%Path%</code> 返回相同的值，但在 Maven 中会区分 <code>$&#123;env.PATH&#125;</code> 和 <code>$&#123;env.Path&#125;</code>。为提高可靠性，环境变量的名称均为大写。</p>
</li>
<li><p><code>project.x</code>：POM 中以点(<code>.</code>)表示的路径将包含相应元素的值，例如，<code>&lt;project&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt;</code> 可以通过 <code>$&#123;project.version&#125;</code> 访问。</p>
</li>
<li><p><code>settings.x</code>：<code>settings.xml</code> 中以点(.)表示的路径将包含相应元素的值，例如，<code>&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt;</code> 可以通过 <code>$&#123;settings.offline&#125;</code> 访问。</p>
</li>
<li><p>Java 系统属性：所有可以通过 <code>java.lang.System.getProperties()</code> 访问的属性都可以作为 POM 属性被访问，例如 <code>$&#123;java.home&#125;</code>。</p>
</li>
<li><p><code>x</code>: 在 POM 的 <code>&lt;properties /&gt;</code> 中被设置的元素，<code>&lt;properties&gt;&lt;someVar&gt;value&lt;/someVar&gt;&lt;/properties&gt;</code> 的值可以通过 <code>$&#123;someVar&#125;</code> 访问。</p>
</li>
</ol>
<h1 id="3-构建设置"><a href="#3-构建设置" class="headerlink" title="3. 构建设置"></a>3. 构建设置</h1><p>除了上面给出的 POM 基础之外，还需要了解另外两个元素：<code>build</code> 元素，用于声明项目的目录结构和管理插件等；<code>reporting</code> 元素，用于报告。</p>
<h2 id="3-1-Build"><a href="#3-1-Build" class="headerlink" title="3.1 Build"></a>3.1 Build</h2><p>根据 POM 4.0.0 XSD，<code>build</code> 元素被概念性地分为两个部分：一种是 <code>BaseBuild</code> 类型，包括两个 <code>build</code> 元素（在 <code>project</code> 下的顶层 build 元素以及 <code>profiles</code> 下的 build 元素，如下所述）共同的元素集；另一种是 <code>Build</code> 类型，包括 <code>BaseBuild</code> 集合以及更多用于顶层定义的元素。首先来分析两种类型之间的共同元素。</p>
<p>注意：这些不同的 <code>build</code> 元素可以被表示为 “project build” 和 “profile build” 。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;!-- &quot;Project Build&quot; contains more elements than just the BaseBuild set --&gt;
  &lt;build&gt;...&lt;/build&gt;
 
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;!-- &quot;Profile Build&quot; contains a subset of &quot;Project Build&quot;s elements --&gt;
      &lt;build&gt;...&lt;/build&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</code></pre>
<h3 id="3-1-1-BaseBuild-元素集合"><a href="#3-1-1-BaseBuild-元素集合" class="headerlink" title="3.1.1 BaseBuild 元素集合"></a>3.1.1 BaseBuild 元素集合</h3><p>正如它的名字， <code>BaseBuild</code> 是 POM 中两种 <code>build</code> 元素的基础元素集合。</p>
<pre><code class="xml">&lt;build&gt;
  &lt;defaultGoal&gt;install&lt;/defaultGoal&gt;
  &lt;directory&gt;$&#123;basedir&#125;/target&lt;/directory&gt;
  &lt;finalName&gt;$&#123;artifactId&#125;-$&#123;version&#125;&lt;/finalName&gt;
  &lt;filters&gt;
    &lt;filter&gt;filters/filter1.properties&lt;/filter&gt;
  &lt;/filters&gt;
  ...
&lt;/build&gt;
</code></pre>
<ul>
<li><p><strong>defaultGoal</strong>: 如果没有指定，Maven 将执行的默认目标或阶段。如果指定了目标，那么它需要和命令行中定义的相同（例如 jar:jar）。指定了阶段时情况也是一样的（例如 install）。</p>
</li>
<li><p><strong>directory</strong>: 这是构建转储其文件的目录，或者用 Maven 的说法，构建的目标位置，它的默认值是 <code>$&#123;basedir&#125;/target</code> 。</p>
</li>
<li><p><strong>finalName</strong>: 这是项目最终构建时的名称（不包括文件扩展名，例如：<code>my-project-1.0.jar</code> ），默认值是 <code>$&#123;artifactId&#125;-$&#123;version&#125;</code> 。然而术语 “finalName” 是有一点用词不当的，因为构建项目的插件完全有权忽略或修改这个名字（但他们通常不会这么做）。例如，如果插件 <code>maven-jar-plugin</code> 给一个 jar 配置了 test 分类，那么上面定义的 jar 会被构建为 <code>my-project-1.0-test.jar</code> 。</p>
</li>
<li><p><strong>filter</strong>: 定义包括了一系列属性的 <code>*.properties</code> 文件，这些属性会应用到接受它们配置的资源（如下所述）。换句话说，在 filter 文件中定义的 “name=value” 对会在构建时替换资源中的 <code>$&#123;name&#125;</code> 字符串。上面的示例中定义了 <code>filters/</code> 目录下的 <code>filter1.properties</code> 文件。Maven 的默认 filter 目录是 <code>$&#123;basedir&#125;/src/main/filters/</code> 。要更全面地了解 filter 是什么以及它们可以做什么，查看<a target="_blank" rel="noopener" href="https://maven.apache.org/guides/getting-started">快速入门指南</a>。</p>
</li>
</ul>
<p><strong>Resources</strong></p>
<p><code>build</code> 元素的另一个功能是指定 resources 在你的项目中存在的位置。Resources 通常不是代码，它们不会被编译，但是会被绑定在项目中或者被用于各种其他原因，例如代码生成。</p>
<p>例如，一个 Plexus 项目需要在 <code>META-INF/plexus</code> 目录下包含一个 <code>configuration.xml</code> 文件（该文件为容器指定组件配置）。尽管我们可以简单的将该文件放置在 <code>src/main/resources/META-INF/plexus</code> 目录下，但我们更倾向于给 Plexus 一个自己的目录 <code>src/main/plexus</code> 。为了让 JAR 插件正确的绑定资源，你需要按下面的方式指定资源：</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;build&gt;
    ...
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;targetPath&gt;META-INF/plexus&lt;/targetPath&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;directory&gt;$&#123;basedir&#125;/src/main/plexus&lt;/directory&gt;
        &lt;includes&gt;
          &lt;include&gt;configuration.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;**/*.properties&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
      ...
    &lt;/testResources&gt;
    ...
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li><p><strong>resources</strong>: 是一个 <code>resource</code> 元素的列表，每个 element 元素描述了与项目相关的文件的内容与位置。</p>
</li>
<li><p><strong>targetPath</strong>: 指定放置构建后的 resources 集合的目录结构，默认值是 <code>$&#123;basedir&#125;</code>，打包在 JAR 中的常用指定路径是 <code>META-INF</code>。</p>
</li>
<li><p><strong>filtering</strong>: <code>true</code> 或者 <code>false</code>，表示该资源的 filter 是否被启用。注意，进行过滤不需要定义 <code>*.properties</code> 文件 —— 资源还可以默认使用在 POM 中定义的属性（例如 <code>$&#123;project.version&#125;</code>），使用通过 <code>-D</code> 传递给命令行的属性（例如 <code>-Dname=value</code>）或者使用由 <code>properties</code> 元素显示定义的属性。Filter 文件已经在上面介绍过。</p>
</li>
<li><p><strong>directory</strong>: 定义位于哪里的资源需要被绑定，默认值为 <code>$&#123;basedir&#125;/src/main/resources</code> 。</p>
</li>
<li><p><strong>includes</strong>: 一组文件表达式，将指定目录下的文件引用为资源，使用 <code>*</code> 作为通配符。</p>
</li>
<li><p><strong>excludes</strong>: 与 <code>includes</code> 结构相同，指定需要忽略哪些文件，如果 <code>includes</code> 和 <code>excludes</code> 之间产生了冲突，那么按照 excludes 执行。</p>
</li>
<li><p><strong>testResources</strong>: 包括 <code>testResource</code> 元素，它们的定义和 <code>resource</code> 元素相似，但是只在 test 阶段被使用。唯一的不同是一个项目默认的测试资源目录为 <code>$&#123;basedir&#125;/src/test/resources</code>（由超级 POM 定义）。测试资源不会被部署。</p>
</li>
</ul>
<p><strong>Plugins</strong></p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.6&lt;/version&gt;
        &lt;extensions&gt;false&lt;/extensions&gt;
        &lt;inherited&gt;true&lt;/inherited&gt;
        &lt;configuration&gt;
          &lt;classifier&gt;test&lt;/classifier&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;...&lt;/dependencies&gt;
        &lt;executions&gt;...&lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>除 <code>groupId:artifactId:version</code> 标准体系之外，还有其他元素可配置插件或配置与该插件交互的构建：</p>
<ul>
<li><p><strong>extensions</strong>: <code>true</code> 或者 <code>false</code>，是否加载该插件的扩展，默认为 <code>false</code>。后面会详细介绍扩展。</p>
</li>
<li><p><strong>inherited</strong>: <code>true</code> 或者 <code>false</code>，该插件的配置是否会被继承，默认值为 <code>true</code>。</p>
</li>
<li><p><strong>configuration</strong>: 特定于单个插件。这里无需深入了解插件的工作机制，只说明插件 Mojo 可能期望的任何属性（Java Mojo bean 中的 getters 和 setters）都可以在这里指定。在上面的示例中，我们设置了 <code>maven-jar-plugin</code> Mojo 中的 classifier 属性为 test 。值得注意的是，所有配置元素，无论它们位于POM中的何处，都旨在将值传递给另一个底层系统，例如插件。换句话说：POM 模式从来不会显式地要求 <code>configuration</code> 元素中的值，但是插件的目标完全有权要求配置值。</p>
<p>如果你的 POM 声明了父 POM，它即会继承父 POM <strong>build/plugins</strong> 中的配置，又会继承父 POM <strong>pluginManagement</strong> 中的配置。</p>
<ul>
<li><p>默认配置继承：</p>
<p>为了说明这一点，假设有以下来自父 POM 的片段:</p>
<pre><code class="xml">&lt;plugin&gt;
  &lt;groupId&gt;my.group&lt;/groupId&gt;
  &lt;artifactId&gt;my-plugin&lt;/artifactId&gt;
  &lt;configuration&gt;
    &lt;items&gt;
      &lt;item&gt;parent-1&lt;/item&gt;
      &lt;item&gt;parent-2&lt;/item&gt;
    &lt;/items&gt;
    &lt;properties&gt;
      &lt;parentKey&gt;parent&lt;/parentKey&gt;
    &lt;/properties&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>并且假设有如下项目的插件配置，是上面 POM 的子项目：</p>
<pre><code class="xml">&lt;plugin&gt;
  &lt;groupId&gt;my.group&lt;/groupId&gt;
  &lt;artifactId&gt;my-plugin&lt;/artifactId&gt;
  &lt;configuration&gt;
    &lt;items&gt;
      &lt;item&gt;child-1&lt;/item&gt;
    &lt;/items&gt;
    &lt;properties&gt;
      &lt;childKey&gt;child&lt;/childKey&gt;
    &lt;/properties&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>默认的行为是根据元素名合并配置元素的内容。如果子 POM 有特定的元素，那么该元素的值成为有效值。如果子 POM 没有某一个元素，但父 POM 有，则父 POM 的值将成为有效值。注意，这纯粹是对 XML 的操作；不涉及插件本身的任何代码或配置；只涉及元素，而不涉及它们的值。</p>
<p>将这些规则应用到示例中，Maven 会得到:</p>
<pre><code class="xml">&lt;plugin&gt;
  &lt;groupId&gt;my.group&lt;/groupId&gt;
  &lt;artifactId&gt;my-plugin&lt;/artifactId&gt;
  &lt;configuration&gt;
    &lt;items&gt;
      &lt;item&gt;child-1&lt;/item&gt;
    &lt;/items&gt;
    &lt;properties&gt;
      &lt;childKey&gt;child&lt;/childKey&gt;
      &lt;parentKey&gt;parent&lt;/parentKey&gt;
    &lt;/properties&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
</li>
<li><p>高级配置继承：<code>combine.children</code> 和 <code>combine.self</code></p>
<p>你可以通过向配置元素的子元素添加属性来控制子POMs如何从父POMs继承配置，该属性是 <code>combine.children</code> 和 <code>combine.self</code>。在子 POM 中使用这些属性来控制 Maven 如何将来自父 POM 的插件配置与子 POM 中的显式配置相结合。</p>
<p>下面是拥有两个属性说明的子配置:</p>
<pre><code class="xml">&lt;configuration&gt;
  &lt;items combine.children=&quot;append&quot;&gt;
    &lt;!-- combine.children=&quot;merge&quot; is the default --&gt;
    &lt;item&gt;child-1&lt;/item&gt;
  &lt;/items&gt;
  &lt;properties combine.self=&quot;override&quot;&gt;
    &lt;!-- combine.self=&quot;merge&quot; is the default --&gt;
    &lt;childKey&gt;child&lt;/childKey&gt;
  &lt;/properties&gt;
&lt;/configuration&gt;
</code></pre>
<p>现在，有效的结果如下:</p>
<pre><code class="xml">&lt;configuration&gt;
  &lt;items combine.children=&quot;append&quot;&gt;
    &lt;item&gt;parent-1&lt;/item&gt;
    &lt;item&gt;parent-2&lt;/item&gt;
    &lt;item&gt;child-1&lt;/item&gt;
  &lt;/items&gt;
  &lt;properties combine.self=&quot;override&quot;&gt;
    &lt;childKey&gt;child&lt;/childKey&gt;
  &lt;/properties&gt;
&lt;/configuration&gt;
</code></pre>
<p><strong>combine.children=”append”</strong> 导致按顺序连接父元素和子元素；另一方面，<strong>combine.self=”override”</strong> 完全覆盖父元素。你不能在一个元素上同时使用 <strong>combine.self=”override”</strong> 和 <strong>combine.children=”append”</strong> ，如果你尝试那么做，override 会起作用。</p>
<p>注意，combine 属性只应用于声明了它们的配置元素，而不会传播到嵌套元素中。也就是说，如果子 POM 的 item 元素的内容是复杂结构，而不是文本，那么它的子元素仍将服从默认的 merge 策略，除非它们本身声明了 combine 属性。</p>
<p><code>combine.*</code> 属性会从父 POMs 继承到子 POMs，谨慎地将这些属性添加到父 POM，因为这可能会影响子 POM 或孙子 POM。</p>
</li>
</ul>
</li>
<li><p><strong>dependencies</strong>: 在 POM 中可以多次看到 <code>dependencies</code> ，并且 <code>dependencies</code> 是所有 <code>plugin</code> 元素块下的一个元素。此处的 dependencies 与基础信息下的 dependencies 有相同的结构和功能，主要的不同是此处的依赖不是项目应用的，而是插件应用的。这个功能的强大之处在于改变插件的依赖列表，可能是通过 exclusions 删除一个未使用的运行时依赖项，或者是通过更改所需依赖项的版本。相关信息，请参阅上面的依赖小节。</p>
</li>
<li><p><strong>executions</strong>: 重要的是要记住，一个插件可能有多个目标。每个目标可能有一个单独的配置，甚至可能将一个插件的目标绑定到完全不同的阶段。<code>executions</code> 配置插件目标的 <code>execution</code>。<br>例如，假设你想将 <code>antrun:run</code> 目标绑定到 <code>verify</code> 阶段。我们希望任务 echo 构建目录，并通过将 <code>inherited</code> 设置为 <code>false</code> 避免将此配置传递给它的子项目。你需要如下的 <code>execution</code>：</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.1&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;echodir&lt;/id&gt;
            &lt;goals&gt;
              &lt;goal&gt;run&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;phase&gt;verify&lt;/phase&gt;
            &lt;inherited&gt;false&lt;/inherited&gt;
            &lt;configuration&gt;
              &lt;tasks&gt;
                &lt;echo&gt;Build Dir: $&#123;project.build.directory&#125;&lt;/echo&gt;
              &lt;/tasks&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li><p>id: 在所有 executions 中指定当前 execution。运行该阶段时，会以 <code>[plugin:goal execution: id]</code> 的形式显示。在上面的示例中即：<code>[antrun:run execution: echodir]</code>。</p>
</li>
<li><p>goals: 像所有的复数 POM 元素一样，它包含一系列单数元素。在上面的示例中，由 <code>execution</code> 块指定了插件 <code>goals</code>。</p>
</li>
<li><p>phase: 指定 <code>goals</code> 在哪个阶段执行。这是一个非常强大的选项，允许将任何目标绑定到构建生命周期中的任何阶段，从而改变 Maven 的默认行为。</p>
</li>
<li><p>inherited: 与上面的 <code>inherited</code> 元素一样，将其设置为 <code>false</code> 将阻止 Maven 将此 <code>execution</code> 传递给它的子元素。这个元素只对父 POM 有意义。</p>
</li>
<li><p>configuration: 与上面的 <code>configuration</code> 元素一样，但是将配置限制在这个特定的目标列表中，而不是插件下的所有目标。</p>
</li>
</ul>
</li>
</ul>
<p><strong>Plugin Management</strong></p>
<ul>
<li><strong>pluginManagement</strong>: 会在 <code>plugins</code> 旁边看到该元素。插件管理以大概相同的方式包含 <code>plugin</code> 元素，只不过它不是为这个特定的项目构建配置插件信息，而是用于配置从此项目继承的项目。但是，这只配置在子 POM 或当前 POM 中的 <code>plugins</code> 元素中实际引用了的插件。子 POM 完全有权利覆盖 <code>pluginManagement</code> 定义。</li>
</ul>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;build&gt;
    ...
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.6&lt;/version&gt;
          &lt;executions&gt;
            &lt;execution&gt;
              &lt;id&gt;pre-process-classes&lt;/id&gt;
              &lt;phase&gt;compile&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;jar&lt;/goal&gt;
              &lt;/goals&gt;
              &lt;configuration&gt;
                &lt;classifier&gt;pre-process&lt;/classifier&gt;
              &lt;/configuration&gt;
            &lt;/execution&gt;
          &lt;/executions&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
    ...
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>如果我们将这些插件信息添加到 <code>plugins</code> 元素中，它们将只应用于单个 POM 。但是，如果我们在 <code>pluginManagement</code> 元素下应用它们，那么这个 POM 和所有将 <code>maven-jar-plugin</code> 添加到 <code>build</code> 中的子 POM 也将得到 <code>pre-process-classes</code> execution。因此，不需要在每个子 <code>pom.xml</code> 中都包含上述混乱的内容，只需要添加以下内容：</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    ...
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h3 id="3-1-2-Build-元素集合"><a href="#3-1-2-Build-元素集合" class="headerlink" title="3.1.2 Build 元素集合"></a>3.1.2 Build 元素集合</h3><p>在 XSD 中的 <code>Build</code> 类型表示那些只可用于 “project build” 中的元素。尽管额外的元素有 6 个，但是实际上 “project build” 所包含的元素只有两组是 “profile build” 所缺少的：directories 和 extensions。</p>
<p><strong>Directories</strong></p>
<p><code>directory</code> 元素集位于 parent build 元素中，parent build 元素为整个 POM 设置了各种目录结构。由于它们不存在于 profile build 中，因此不能由 profiles 更改。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;build&gt;
    &lt;sourceDirectory&gt;$&#123;basedir&#125;/src/main/java&lt;/sourceDirectory&gt;
    &lt;scriptSourceDirectory&gt;$&#123;basedir&#125;/src/main/scripts&lt;/scriptSourceDirectory&gt;
    &lt;testSourceDirectory&gt;$&#123;basedir&#125;/src/test/java&lt;/testSourceDirectory&gt;
    &lt;outputDirectory&gt;$&#123;basedir&#125;/target/classes&lt;/outputDirectory&gt;
    &lt;testOutputDirectory&gt;$&#123;basedir&#125;/target/test-classes&lt;/testOutputDirectory&gt;
    ...
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>If the values of a <code>*Directory</code> element above is set as an absolute path (when their properties are expanded) then that directory is used. Otherwise, it is relative to the base build directory: <code>$&#123;basedir&#125;</code>. Please note that the <code>scriptSourceDirectory</code> is nowhere used in Maven and is obsolete.<br>如果上面的 <code>*Directory</code> 元素的值被设置为绝对路径，那么该目录将被使用。否则，它相对于基本构建目录：<code>$&#123;basedir&#125;</code> 。注意，<code>scriptSourceDirectory</code> 在 Maven 中无处可用，并且已经过时。</p>
<p><strong>Extensions</strong></p>
<p>扩展是将在此构建中使用的组件列表，它们将包含在正在运行的构建的类路径中。它们可以为构建过程提供扩展（例如为 Wagon 传输机制添加 ftp provider），也可以激活对构建生命周期进行更改的插件。简而言之，扩展是在构建期间激活的组件。扩展实际上不必做任何事情，也不包含 Mojo 。因此，扩展非常适合指定一个通用插件接口的多个实现中的一个。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;build&gt;
    ...
    &lt;extensions&gt;
      &lt;extension&gt;
        &lt;groupId&gt;org.apache.maven.wagon&lt;/groupId&gt;
        &lt;artifactId&gt;wagon-ftp&lt;/artifactId&gt;
        &lt;version&gt;1.0-alpha-3&lt;/version&gt;
      &lt;/extension&gt;
    &lt;/extensions&gt;
    ...
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h2 id="3-2-Reporting"><a href="#3-2-Reporting" class="headerlink" title="3.2 Reporting"></a>3.2 Reporting</h2><p>Reporting contains the elements that correspond specifically for the site generation phase. Certain Maven plugins can generate reports defined and configured under the reporting element, for example: generating Javadoc reports. Much like the build element’s ability to configure plugins, reporting commands the same ability. The glaring difference is that rather than fine-grained control of plug-in goals within the executions block, reporting configures goals within reportSet elements. And the subtler difference is that a plugin configuration under the reporting element works as build plugin configuration, although the opposite is not true (a build plugin configuration does not affect a reporting plugin).</p>
<p>Possibly the only item under the reporting element that would not be familiar to someone who understood the build element is the Boolean excludeDefaults element. This element signifies to the site generator to exclude reports normally generated by default. When a site is generated via the site build cycle, a Project Info section is placed in the left-hand menu, chock full of reports, such as the Project Team report or Dependencies list report. These report goals are generated by maven-project-info-reports-plugin. Being a plugin like any other, it may also be suppressed in the following, more verbose, way, which effectively turns off project-info reports.</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;reporting&gt;
    &lt;outputDirectory&gt;$&#123;basedir&#125;/target/site&lt;/outputDirectory&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.0.1&lt;/version&gt;
        &lt;reportSets&gt;
          &lt;reportSet&gt;&lt;/reportSet&gt;
        &lt;/reportSets&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/reporting&gt;
  ...
&lt;/project&gt;
</code></pre>
<p>The other difference is the outputDirectory element under plugin. In the case of reporting, the output directory is ${basedir}/target/site by default.</p>
<h3 id="3-2-1-Report-集合"><a href="#3-2-1-Report-集合" class="headerlink" title="3.2.1 Report 集合"></a>3.2.1 Report 集合</h3><p>It is important to keep in mind that an individual plugin may have multiple goals. Each goal may have a separate configuration. Report sets configure execution of a report plugin’s goals. Does this sound familiar - deja-vu? The same thing was said about build’s execution element with one difference: you cannot bind a report to another phase. Sorry.</p>
<p>For example, suppose you wanted to configure the javadoc:javadoc goal to link to “<a target="_blank" rel="noopener" href="http://java.sun.com/j2se/1.5.0/docs/api/&quot;">http://java.sun.com/j2se/1.5.0/docs/api/&quot;</a>, but only the javadoc goal (not the goal maven-javadoc-plugin:jar). We would also like this configuration passed to its children, and set inherited to true. The reportSet would resemble the following:</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;reporting&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        ...
        &lt;reportSets&gt;
          &lt;reportSet&gt;
            &lt;id&gt;sunlink&lt;/id&gt;
            &lt;reports&gt;
              &lt;report&gt;javadoc&lt;/report&gt;
            &lt;/reports&gt;
            &lt;inherited&gt;true&lt;/inherited&gt;
            &lt;configuration&gt;
              &lt;links&gt;
                &lt;link&gt;http://java.sun.com/j2se/1.5.0/docs/api/&lt;/link&gt;
              &lt;/links&gt;
            &lt;/configuration&gt;
          &lt;/reportSet&gt;
        &lt;/reportSets&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/reporting&gt;
  ...
&lt;/project&gt;
</code></pre>
<p>Between build executions and reporting reportSets, it should be clear now as to why they exist. In the simplest sense, they drill down in configuration. The POM must have a way not only to configure plugins, but must also configure the goals of those plugins. That is where these elements come in, giving the POM ultimate granularity in control of its build destiny.</p>
<h1 id="4-更多项目信息"><a href="#4-更多项目信息" class="headerlink" title="4. 更多项目信息"></a>4. 更多项目信息</h1><p>Several elements do not affect the build, but rather document the project for the convenience of developers. Many of these elements are used to fill in project details when generating the project’s web site. However, like all POM declarations, plugins can use them for anything. The following are the simplest elements:</p>
<ul>
<li><p>name: Projects tend to have conversational names, beyond the artifactId. The Sun engineers did not refer to their project as “java-1.5”, but rather just called it “Tiger”. Here is where to set that value.</p>
</li>
<li><p>description: A short, human readable description of the project. Although this should not replace formal documentation, a quick comment to any readers of the POM is always helpful.</p>
</li>
<li><p>url: The project’s home page.</p>
</li>
<li><p>inceptionYear: The year the project was first created.</p>
</li>
</ul>
<h2 id="4-1-Licenses"><a href="#4-1-Licenses" class="headerlink" title="4.1 Licenses"></a>4.1 Licenses</h2><pre><code class="xml">&lt;licenses&gt;
  &lt;license&gt;
    &lt;name&gt;Apache-2.0&lt;/name&gt;
    &lt;url&gt;https://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt;
    &lt;distribution&gt;repo&lt;/distribution&gt;
    &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;
  &lt;/license&gt;
&lt;/licenses&gt;
</code></pre>
<p>Licenses are legal documents defining how and when a project (or parts of a project) may be used. A project should list licenses that apply directly to this project, and not list licenses that apply to the project’s dependencies.</p>
<ul>
<li><p>name, url and comments: are self explanatory, and have been encountered before in other contexts. Using an SPDX identifier as the license name is recommended. The fourth license element is:</p>
</li>
<li><p>distribution: This describes how the project may be legally distributed. The two stated methods are repo (they may be downloaded from a Maven repository) or manual (they must be manually installed).</p>
</li>
</ul>
<h2 id="4-2-Organizations"><a href="#4-2-Organizations" class="headerlink" title="4.2 Organizations"></a>4.2 Organizations</h2><p>Most projects are run by some sort of organization (business, private group, etc.). Here is where the most basic information is set.</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;organization&gt;
    &lt;name&gt;Codehaus Mojo&lt;/name&gt;
    &lt;url&gt;http://mojo.codehaus.org&lt;/url&gt;
  &lt;/organization&gt;
&lt;/project&gt;
</code></pre>
<h2 id="4-3-Developers"><a href="#4-3-Developers" class="headerlink" title="4.3 Developers"></a>4.3 Developers</h2><p>All projects consist of files that were created, at some time, by a person. Like the other systems that surround a project, so to do the people involved with a project have a stake in the project. Developers are presumably members of the project’s core development. Note that, although an organization may have many developers (programmers) as members, it is not good form to list them all as developers, but only those who are immediately responsible for the code. A good rule of thumb is, if the person should not be contacted about the project, they do not need to be listed here.</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;developers&gt;
    &lt;developer&gt;
      &lt;id&gt;jdoe&lt;/id&gt;
      &lt;name&gt;John Doe&lt;/name&gt;
      &lt;email&gt;jdoe@example.com&lt;/email&gt;
      &lt;url&gt;http://www.example.com/jdoe&lt;/url&gt;
      &lt;organization&gt;ACME&lt;/organization&gt;
      &lt;organizationUrl&gt;http://www.example.com&lt;/organizationUrl&gt;
      &lt;roles&gt;
        &lt;role&gt;architect&lt;/role&gt;
        &lt;role&gt;developer&lt;/role&gt;
      &lt;/roles&gt;
      &lt;timezone&gt;America/New_York&lt;/timezone&gt;
      &lt;properties&gt;
        &lt;picUrl&gt;http://www.example.com/jdoe/pic&lt;/picUrl&gt;
      &lt;/properties&gt;
    &lt;/developer&gt;
  &lt;/developers&gt;
  ...
&lt;/project&gt;
</code></pre>
<ul>
<li><p>id, name, email: These correspond to the developer’s ID (presumably some unique ID across an organization), the developer’s name and email address.</p>
</li>
<li><p>organization, organizationUrl: As you probably guessed, these are the developer’s organization name and it’s URL, respectively.</p>
</li>
<li><p>roles: A role should specify the standard actions that the person is responsible for. Like a single person can wear many hats, a single person can take on multiple roles.</p>
</li>
<li><p>timezone: A valid time zone ID like America/New_York or Europe/Berlin, or a numerical offset in hours (and fraction) from UTC where the developer lives, e.g., -5 or +1. Time zone IDs are highly preferred because they are not affected by DST and time zone shifts. Refer to the IANA for the official time zone database and a listing in Wikipedia.</p>
</li>
<li><p>properties: This element is where any other properties about the person goes. For example, a link to a personal image or an instant messenger handle. Different plugins may use these properties, or they may simply be for other developers who read the POM.</p>
</li>
</ul>
<h2 id="4-4-Contributors"><a href="#4-4-Contributors" class="headerlink" title="4.4 Contributors"></a>4.4 Contributors</h2><p>Contributors are like developers yet play an ancillary role in a project’s lifecycle. Perhaps the contributor sent in a bug fix, or added some important documentation. A healthy open source project will likely have more contributors than developers.</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;contributors&gt;
    &lt;contributor&gt;
      &lt;name&gt;Noelle&lt;/name&gt;
      &lt;email&gt;some.name@gmail.com&lt;/email&gt;
      &lt;url&gt;http://noellemarie.com&lt;/url&gt;
      &lt;organization&gt;Noelle Marie&lt;/organization&gt;
      &lt;organizationUrl&gt;http://noellemarie.com&lt;/organizationUrl&gt;
      &lt;roles&gt;
        &lt;role&gt;tester&lt;/role&gt;
      &lt;/roles&gt;
      &lt;timezone&gt;America/Vancouver&lt;/timezone&gt;
      &lt;properties&gt;
        &lt;gtalk&gt;some.name@gmail.com&lt;/gtalk&gt;
      &lt;/properties&gt;
    &lt;/contributor&gt;
  &lt;/contributors&gt;
  ...
&lt;/project&gt;
</code></pre>
<p>Contributors contain the same set of elements than developers sans the id element.</p>
<h1 id="5-环境设置"><a href="#5-环境设置" class="headerlink" title="5. 环境设置"></a>5. 环境设置</h1><h2 id="5-1-Issue-管理"><a href="#5-1-Issue-管理" class="headerlink" title="5.1 Issue 管理"></a>5.1 Issue 管理</h2><p>Issue 管理定义了 bug 跟踪系统 (Bugzilla, TestTrack, ClearQuest, etc) 的使用。尽管没有什么可以阻止插件将这些信息用于某些目的，但它主要用于生成项目文档。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;issueManagement&gt;
    &lt;system&gt;Bugzilla&lt;/system&gt;
    &lt;url&gt;http://127.0.0.1/bugzilla/&lt;/url&gt;
  &lt;/issueManagement&gt;
  ...
&lt;/project&gt;
</code></pre>
<h2 id="5-2-持续集成管理"><a href="#5-2-持续集成管理" class="headerlink" title="5.2 持续集成管理"></a>5.2 持续集成管理</h2><p>在过去几年中，相对于手动构建，基于触发器或时间（例如，每小时或每天）的持续集成构建系统越来越受青睐。随着构建系统变得更加标准化，运行触发这些构建的系统也变得更加标准化。尽管大部分配置取决于所使用的特定程序（Continuum、Cruise Control 等），但有一些配置可能会在 POM 中进行。Maven 已经捕获了一组 notifier 元素中的一些重复设置。notifier 是通知人们某些构建状态的方式。在下面的例子中，这个 POM 正在设置一个 <code>mail</code> 类型的 notifier，并配置电子邮件地址以用于指定的触发器 <code>sendOnError</code>、<code>sendOnFailure</code>，没有 <code>sendOnSuccess</code> 或 <code>sendOnWarning</code>。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;ciManagement&gt;
    &lt;system&gt;continuum&lt;/system&gt;
    &lt;url&gt;http://127.0.0.1:8080/continuum&lt;/url&gt;
    &lt;notifiers&gt;
      &lt;notifier&gt;
        &lt;type&gt;mail&lt;/type&gt;
        &lt;sendOnError&gt;true&lt;/sendOnError&gt;
        &lt;sendOnFailure&gt;true&lt;/sendOnFailure&gt;
        &lt;sendOnSuccess&gt;false&lt;/sendOnSuccess&gt;
        &lt;sendOnWarning&gt;false&lt;/sendOnWarning&gt;
        &lt;configuration&gt;&lt;address&gt;continuum@127.0.0.1&lt;/address&gt;&lt;/configuration&gt;
      &lt;/notifier&gt;
    &lt;/notifiers&gt;
  &lt;/ciManagement&gt;
  ...
&lt;/project&gt;
</code></pre>
<h2 id="5-3-邮件列表"><a href="#5-3-邮件列表" class="headerlink" title="5.3 邮件列表"></a>5.3 邮件列表</h2><p>邮件列表是联系项目相关人员的绝佳工具。大多数邮件列表面向开发人员和用户。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;mailingLists&gt;
    &lt;mailingList&gt;
      &lt;name&gt;User List&lt;/name&gt;
      &lt;subscribe&gt;user-subscribe@127.0.0.1&lt;/subscribe&gt;
      &lt;unsubscribe&gt;user-unsubscribe@127.0.0.1&lt;/unsubscribe&gt;
      &lt;post&gt;user@127.0.0.1&lt;/post&gt;
      &lt;archive&gt;http://127.0.0.1/user/&lt;/archive&gt;
      &lt;otherArchives&gt;
        &lt;otherArchive&gt;http://base.google.com/base/1/127.0.0.1&lt;/otherArchive&gt;
      &lt;/otherArchives&gt;
    &lt;/mailingList&gt;
  &lt;/mailingLists&gt;
  ...
&lt;/project&gt;
</code></pre>
<ul>
<li>subscribe, unsubscribe: 指定用于执行相关操作的电子邮件地址。要订阅上面的用户列表，用户可以发送电子邮件至 <a href="mailto:&#x75;&#x73;&#x65;&#x72;&#45;&#115;&#117;&#98;&#x73;&#x63;&#x72;&#x69;&#x62;&#101;&#64;&#x31;&#x32;&#55;&#46;&#48;&#x2e;&#48;&#x2e;&#49;">&#x75;&#x73;&#x65;&#x72;&#45;&#115;&#117;&#98;&#x73;&#x63;&#x72;&#x69;&#x62;&#101;&#64;&#x31;&#x32;&#55;&#46;&#48;&#x2e;&#48;&#x2e;&#49;</a>。</li>
<li>archive: 指定旧邮件列表电子邮件存档的 url（如果存在）。如果有镜像档案，它们可以在 otherArchives 下指定。</li>
<li>post: 用于发布到邮件列表的电子邮件地址。请注意，并非所有邮件列表都有能力发布（例如构建失败列表）。</li>
</ul>
<h2 id="5-4-SCM"><a href="#5-4-SCM" class="headerlink" title="5.4 SCM"></a>5.4 SCM</h2><p>SCM（软件配置管理，也称为源代码/控制管理或简而言之，版本控制）是任何健康项目不可或缺的一部分。如果您的 Maven 项目使用 SCM 系统，那么这里是您存放将该信息的位置。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;scm&gt;
    &lt;connection&gt;scm:svn:http://127.0.0.1/svn/my-project&lt;/connection&gt;
    &lt;developerConnection&gt;scm:svn:https://127.0.0.1/svn/my-project&lt;/developerConnection&gt;
    &lt;tag&gt;HEAD&lt;/tag&gt;
    &lt;url&gt;http://127.0.0.1/websvn/my-project&lt;/url&gt;
  &lt;/scm&gt;
  ...
&lt;/project&gt;
</code></pre>
<ul>
<li><p>connection, developerConnection: The two connection elements convey to how one is to connect to the version control system through Maven. Where connection requires read access for Maven to be able to find the source code (for example, an update), developerConnection requires a connection that will give write access. The Maven project has spawned another project named Maven SCM, which creates a common API for any SCMs that wish to implement it. The most popular are CVS and Subversion, however, there is a growing list of other supported SCMs. All SCM connections are made through a common URL structure.<br><code>scm:[provider]:[provider_specific]</code><br>Where provider is the type of SCM system. For example, connecting to a CVS repository may look like this:<br><code>scm:cvs:pserver:127.0.0.1:/cvs/root:my-project</code></p>
</li>
<li><p>tag: Specifies the tag that this project lives under. HEAD (meaning, the SCM root) is the default.</p>
</li>
<li><p>url: A publicly browsable repository. For example, via ViewCVS.</p>
</li>
</ul>
<h2 id="5-5-先决条件"><a href="#5-5-先决条件" class="headerlink" title="5.5 先决条件"></a>5.5 先决条件</h2><p>The POM may have certain prerequisites in order to execute correctly. For example, perhaps there was a fix in Maven 2.0.3 that you need in order to deploy using sftp.</p>
<p>In Maven 3, use Maven Enforcer Plugin’s requireMavenVersion rule, or other rules to check other aspects.</p>
<p>In Maven 2, here is where you give the prerequisites to building: if these are not met, Maven will fail the build before even starting. The only element that exists as a prerequisite in POM 4.0 is the maven element, which takes a minimum version number. It is checked with Maven 2, it is not any more in Maven 3.</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;prerequisites&gt;
    &lt;maven&gt;2.0.6&lt;/maven&gt;
  &lt;/prerequisites&gt;
  ...
&lt;/project&gt;
</code></pre>
<h2 id="5-6-Repositories"><a href="#5-6-Repositories" class="headerlink" title="5.6 Repositories"></a>5.6 Repositories</h2><p>Repositories are collections of artifacts which adhere to the Maven repository directory layout. In order to be a Maven repository artifact, a POM file must live within the structure $BASE_REPO/groupId/artifactId/version/artifactId-version.pom. $BASE_REPO can be local (file structure) or remote (base URL); the remaining layout will be the same. Repositories exist as a place to collect and store artifacts. Whenever a project has a dependency upon an artifact, Maven will first attempt to use a local copy of the specified artifact. If that artifact does not exist in the local repository, it will then attempt to download from a remote repository. The repository elements within a POM specify those alternate repositories to search.</p>
<p>The repository is one of the most powerful features of the Maven community. By default Maven searches the central repository at <a target="_blank" rel="noopener" href="https://repo.maven.apache.org/maven2/">https://repo.maven.apache.org/maven2/</a>. Additional repositories can be configured in the pom.xml <code>repositories</code> element.</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;releases&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
        &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;
        &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;
      &lt;/releases&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
        &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt;
      &lt;/snapshots&gt;
      &lt;name&gt;Nexus Snapshots&lt;/name&gt;
      &lt;id&gt;snapshots-repo&lt;/id&gt;
      &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;
  &lt;pluginRepositories&gt;
    ...
  &lt;/pluginRepositories&gt;
  ...
&lt;/project&gt;
</code></pre>
<ul>
<li>releases, snapshots: These are the policies for each type of artifact, Release or snapshot. With these two sets, a POM has the power to alter the policies for each type independent of the other within a single repository. For example, one may decide to enable only snapshot downloads, possibly for development purposes.</li>
<li>enabled: true or false for whether this repository is enabled for the respective type (releases or snapshots).<br>updatePolicy: This element specifies how often updates should attempt to occur. Maven will compare the local POM’s timestamp (stored in a repository’s maven-metadata file) to the remote. The choices are: always, daily (default), interval:X (where X is an integer in minutes) or never.</li>
<li>checksumPolicy: When Maven deploys files to the repository, it also deploys corresponding checksum files. Your options are to ignore, fail, or warn on missing or incorrect checksums.</li>
<li>layout: In the above description of repositories, it was mentioned that they all follow a common layout. This is mostly correct. The layout introduced with Maven 2 is the default layout for repositories used by Maven both 2 &amp; 3; however, Maven 1.x had a different layout. Use this element to specify which if it is default or legacy.</li>
</ul>
<h2 id="5-7-Plugin-Repositories"><a href="#5-7-Plugin-Repositories" class="headerlink" title="5.7 Plugin Repositories"></a>5.7 Plugin Repositories</h2><p>Repositories are home to two major types of artifacts. The first are artifacts that are used as dependencies of other artifacts. These are the majority of artifacts that reside within central. The other type of artifact is plugins. Maven plugins are themselves a special type of artifact. Because of this, plugin repositories may be separated from other repositories (although, I have yet to hear a convincing argument for doing so). In any case, the structure of the pluginRepositories element block is similar to the repositories element. The pluginRepository elements each specify a remote location of where Maven can find new plugins.</p>
<h2 id="5-8-Distribution-Management"><a href="#5-8-Distribution-Management" class="headerlink" title="5.8 Distribution Management"></a>5.8 Distribution Management</h2><p>Distribution management acts precisely as it sounds: it manages the distribution of the artifact and supporting files generated throughout the build process. Starting with the last elements first:</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;distributionManagement&gt;
    ...
    &lt;downloadUrl&gt;http://mojo.codehaus.org/my-project&lt;/downloadUrl&gt;
    &lt;status&gt;deployed&lt;/status&gt;
  &lt;/distributionManagement&gt;
  ...
&lt;/project&gt;
</code></pre>
<ul>
<li>downloadUrl: is the URL of the repository which another POM can point to in order to grab this POM’s artifact. In the simplest terms, we told the POM how to upload it (through repository/url), but from where can the public download it? This element answers that question.</li>
<li>status: Warning! Like a baby bird in a nest, the status should never be touched by human hands! The reason for this is that Maven will set the status of the project when it is transported out to the repository. Its valid types are as follows.<ul>
<li>none: No special status. This is the default for a POM.</li>
<li>converted: The manager of the repository converted this POM from an earlier version to Maven 2.</li>
<li>partner: This artifact has been synchronized with a partner repository.</li>
<li>deployed: By far the most common status, meaning that this artifact was deployed from a Maven 2 or 3 instance. This is what you get when you manually deploy using the command-line deploy phase.</li>
<li>verified: This project has been verified, and should be considered finalized.</li>
</ul>
</li>
</ul>
<h3 id="5-8-1-Repository"><a href="#5-8-1-Repository" class="headerlink" title="5.8.1 Repository"></a>5.8.1 Repository</h3><p>Whereas the repositories element specifies in the POM the location and manner in which Maven may download remote artifacts for use by the current project, distributionManagement specifies where (and how) this project will get to a remote repository when it is deployed. The repository elements will be used for snapshot distribution if the snapshotRepository is not defined.</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;distributionManagement&gt;
    &lt;repository&gt;
      &lt;uniqueVersion&gt;false&lt;/uniqueVersion&gt;
      &lt;id&gt;corp1&lt;/id&gt;
      &lt;name&gt;Corporate Repository&lt;/name&gt;
      &lt;url&gt;scp://repo/maven2&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
    &lt;/repository&gt;
    &lt;snapshotRepository&gt;
      &lt;uniqueVersion&gt;true&lt;/uniqueVersion&gt;
      &lt;id&gt;propSnap&lt;/id&gt;
      &lt;name&gt;Propellors Snapshots&lt;/name&gt;
      &lt;url&gt;sftp://propellers.net/maven&lt;/url&gt;
      &lt;layout&gt;legacy&lt;/layout&gt;
    &lt;/snapshotRepository&gt;
    ...
  &lt;/distributionManagement&gt;
  ...
&lt;/project&gt;
</code></pre>
<ul>
<li>id, name: The id is used to uniquely identify this repository amongst many, and the name is a human readable form.</li>
<li>uniqueVersion: The unique version takes a true or false value to denote whether artifacts deployed to this repository should get a uniquely generated version number, or use the version number defined as part of the address.</li>
<li>url: This is the core of the repository element. It specifies both the location and the transport protocol used to transfer a built artifact (and POM file, and checksum data) to the repository.</li>
<li>layout: These are the same types and purpose as the layout element defined in the repository element. They are default and legacy.</li>
</ul>
<h3 id="5-8-2-Site-Distribution"><a href="#5-8-2-Site-Distribution" class="headerlink" title="5.8.2 Site Distribution"></a>5.8.2 Site Distribution</h3><p>More than distribution to the repositories, distributionManagement is responsible for defining how to deploy the project’s site and documentation.</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;distributionManagement&gt;
    ...
    &lt;site&gt;
      &lt;id&gt;mojo.website&lt;/id&gt;
      &lt;name&gt;Mojo Website&lt;/name&gt;
      &lt;url&gt;scp://beaver.codehaus.org/home/projects/mojo/public_html/&lt;/url&gt;
    &lt;/site&gt;
    ...
  &lt;/distributionManagement&gt;
  ...
&lt;/project&gt;
</code></pre>
<ul>
<li>id, name, url: These elements are similar to their counterparts above in the distributionManagement repository element.</li>
</ul>
<h3 id="5-8-3-Relocation"><a href="#5-8-3-Relocation" class="headerlink" title="5.8.3 Relocation"></a>5.8.3 Relocation</h3><pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;1 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;distributionManagement&gt;
    ...
    &lt;relocation&gt;
      &lt;groupId&gt;org.apache&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;message&gt;We have moved the Project under Apache&lt;/message&gt;
    &lt;/relocation&gt;
    ...
  &lt;/distributionManagement&gt;
  ...
&lt;/project&gt;
</code></pre>
<p>Projects are not static; they are living things (or dying things, as the case may be). A common thing that happens as projects grow, is that they are forced to move to more suitable quarters. For example, when your next wildly successful open source project moves under the Apache umbrella, it would be good to give users a heads-up that the project is being renamed to org.apache:my-project:1.0. Besides specifying the new address, it is also good form to provide a message explaining why.</p>
<h2 id="5-9-Profiles"><a href="#5-9-Profiles" class="headerlink" title="5.9 Profiles"></a>5.9 Profiles</h2><p>POM 4.0 的一个新特性是 maven project 能够根据构建环境更改设置。<code>profile</code> 元素包含一个可选的 <code>activation</code>（配置文件触发器）和一组对 POM 的更改（如果该配置文件已被激活）。例如，为测试环境构建的项目可能指向与最终部署不同的数据库；或者可以根据使用的 JDK 版本从不同的存储库中提取依赖项。<code>profiles</code> 的元素如下：</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;test&lt;/id&gt;
      &lt;activation&gt;...&lt;/activation&gt;
      &lt;build&gt;...&lt;/build&gt;
      &lt;modules&gt;...&lt;/modules&gt;
      &lt;repositories&gt;...&lt;/repositories&gt;
      &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;
      &lt;dependencies&gt;...&lt;/dependencies&gt;
      &lt;reporting&gt;...&lt;/reporting&gt;
      &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;
      &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</code></pre>
<h3 id="5-9-1-Activation"><a href="#5-9-1-Activation" class="headerlink" title="5.9.1 Activation"></a>5.9.1 Activation</h3><p>Activations 是 profile 的关键。Profile 的强大之处在于它仅在某些情况下才能修改 POM。这些情况是通过 <code>activation</code> 元素指定的。</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;test&lt;/id&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;
        &lt;jdk&gt;1.5&lt;/jdk&gt;
        &lt;os&gt;
          &lt;name&gt;Windows XP&lt;/name&gt;
          &lt;family&gt;Windows&lt;/family&gt;
          &lt;arch&gt;x86&lt;/arch&gt;
          &lt;version&gt;5.1.2600&lt;/version&gt;
        &lt;/os&gt;
        &lt;property&gt;
          &lt;name&gt;sparrow-type&lt;/name&gt;
          &lt;value&gt;African&lt;/value&gt;
        &lt;/property&gt;
        &lt;file&gt;
          &lt;exists&gt;$&#123;basedir&#125;/file2.properties&lt;/exists&gt;
          &lt;missing&gt;$&#123;basedir&#125;/file1.properties&lt;/missing&gt;
        &lt;/file&gt;
      &lt;/activation&gt;
      ...
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</code></pre>
<p>在 Maven 3.2.2 版本之前，Activation 发生在满足一个或多个指定的条件时，当遇到第一个肯定结果时，停止处理并将该 profile 标记为 active；在 Maven 3.2.2 版本之后，Activation 发生在满足所有指定的条件时。</p>
<ul>
<li><p><strong>jdk</strong>: <code>activation</code> 的 <code>jdk</code> 元素进行一个内置的以 Java 为中心的检查。如果测试在与给定前缀匹配的 jdk 版本号下运行，就会发生激活。在上面的示例中，<code>1.5.0_06</code> 将符合条件。该检查条件还支持范围。有关支持的范围的更多详细信息，请参阅 <a target="_blank" rel="noopener" href="https://maven.apache.org/enforcer/enforcer-rules/versionRanges.html">maven-enforcer-plugin</a>。</p>
</li>
<li><p><strong>os</strong>: <code>activation</code> 的 <code>os</code> 元素可以定义一些如上所示的操作系统特定属性。有关 OS 值的更多详细信息，请参阅 maven-enforcer-plugins <a target="_blank" rel="noopener" href="https://maven.apache.org/enforcer/enforcer-rules/requireOS.html">RequireOS Rule</a>。</p>
</li>
<li><p><strong>property</strong>: 如果 Maven 检测到相关 <code>name=value</code> 对的系统属性或命令行属性（a value which can be dereferenced within the POM by <code>$&#123;name&#125;</code>），<code>profile</code> 会被激活。</p>
</li>
<li><p><strong>file</strong>: 最后，给定的文件名可以通过文件的 <code>existence</code> 或 <code>missing</code> 来激活 <code>profile</code>。注意：此元素的插值仅限于 <code>$&#123;basedir&#125;</code>、系统属性和请求属性。</p>
</li>
</ul>
<p><code>activation</code> 元素不是激活一个配置文件的唯一方法。The <code>settings.xml</code> file’s <code>activeProfile</code> element may contain the profile’s <code>id</code>. They may also be activated explicitly through the command line via a comma separated list after the <code>-P</code> flag (e.g. <code>-P codecoverage</code>).</p>
<p>To see which profile will activate in a certain build, use the <code>maven-help-plugin</code>.</p>
<pre><code class="sh">mvn help:active-profiles
</code></pre>
<h3 id="5-9-2-The-BaseBuild-Element-Set-revisited"><a href="#5-9-2-The-BaseBuild-Element-Set-revisited" class="headerlink" title="5.9.2 The BaseBuild Element Set (revisited)"></a>5.9.2 The BaseBuild Element Set (revisited)</h3><p>如上所述，存在两种类型的 <code>build</code> 元素的原因在于：即 profile 没有必要像在 POM 的顶层那样配置构建目录或扩展。无论在哪个环境中构建项目，有些值将保持不变，例如源代码的目录结构。如果你发现你的项目需要为不同的环境保留两组代码，那么谨慎的做法是将项目重构为两个或多个独立的项目。</p>
<h1 id="6-最终的话"><a href="#6-最终的话" class="headerlink" title="6. 最终的话"></a>6. 最终的话</h1><p>Maven POM 内容很多。然而，它的大小也证明了它的多功能性。至少可以说，Maven POM 将项目的所有方面抽象为单个组件的能力是强大的。为每个项目创建数十种不同的构建脚本和分散的文档的时代已经过去了。与组成 Maven 星系的 Maven 其他明星一起 —— 明确定义的构建生命周期、易于编写和维护的插件、集中式类库、系统范围和用户范围的配置，以及越来越多的工具来帮助开发人员轻松维护复杂的项目 —— POM 是大而明亮的中心。</p>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2022/01/18/Elastic-Observability-%E5%8F%AF%E8%A7%82%E5%AF%9F%E6%80%A7/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          Elastic Observability(可观察性)
        
      </div>
    </a>
  
  
    <a href="/2021/11/21/Hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">Hexo常用命令</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=Maven POM Reference 官方文档 - 杜圆圆的学习笔记&url=https://dquaner.github.io/2021/11/21/Maven-POM-Reference-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=Maven POM Reference 官方文档 - 杜圆圆的学习笔记&u=https://dquaner.github.io/2021/11/21/Maven-POM-Reference-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=Maven POM Reference 官方文档 - 杜圆圆的学习笔记&url=https://dquaner.github.io/2021/11/21/Maven-POM-Reference-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>












</div>
                </section>
            </section>

            
            <aside class="sidebar sidebar-search-fix">
                

    <div class="search">
    <div class="has-icon-right">
        <input type="text" class="form-input" id="search" placeholder="SEARCH" autocomplete="off">
        <div class="form-icon">
            <box-icon name='search' color="#3c4859"></box-icon>
        </div>
    </div>
    <div class="search-result" id="search-ps"></div>
</div>


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ELK/">ELK</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/devOps/">devOps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/">测试开发</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gatling/" rel="tag">Gatling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Monitoring/" rel="tag">Monitoring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/" rel="tag">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/devOps/" rel="tag">devOps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/" rel="tag">全文搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">响应式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2023/01/04/RxJava-JVM-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%89%A9%E5%B1%95/">RxJava: JVM 的响应式扩展</a>
          </li>
        
          <li>
            <a href="/2023/01/03/RxJava-%E5%9F%BA%E7%A1%80/">RxJava 基础</a>
          </li>
        
          <li>
            <a href="/2022/11/28/Elasticsearch%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8/">Elasticsearch（一）入门</a>
          </li>
        
          <li>
            <a href="/2022/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">设计模式：七大设计原则</a>
          </li>
        
          <li>
            <a href="/2022/08/06/GIT-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">GIT 常用命令</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            杜圆圆的学习笔记 &copy; 2023<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1637200696663.js"></script>


<script src="/dist/custom.js?1637200696663.js"></script>









</body>

</html>